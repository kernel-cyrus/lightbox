<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The QEMU Object Model (QOM) &mdash; QEMU  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/qemu_32x32.png"/>
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/custom.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Atomic operations in QEMU" href="atomics.html" />
    <link rel="prev" title="Internal Subsystem Information" href="index-internals.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #802400" >
            <a href="../index.html" class="icon icon-home"> QEMU
            <img src="../_static/qemu_128x128.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                10.0.50
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">About QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/index.html">System Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User Mode Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interop/index.html">System Emulation Management and Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../specs/index.html">System Emulation Guest Hardware Specifications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Information</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index-process.html">QEMU Community Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-build.html">QEMU Build System</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing/index.html">Testing QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-api.html">Internal QEMU APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index-internals.html">Internal Subsystem Information</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">The QEMU Object Model (QOM)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-qom-tree">The QOM tree</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-qom-class">Creating a QOM class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standard-type-declaration-and-definition-macros">Standard type declaration and definition macros</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-life-cycle">Device Life-cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="atomics.html">Atomic operations in QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="rcu.html">Using RCU (Read-Copy-Update) for synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="block-coroutine-wrapper.html">block-coroutine-wrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="clocks.html">Modelling a clock tree in QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="ebpf_rss.html">eBPF RSS virtio-net support</a></li>
<li class="toctree-l3"><a class="reference internal" href="migration/index.html">Migration</a></li>
<li class="toctree-l3"><a class="reference internal" href="multi-process.html">Multi-process QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="reset.html">Reset in QEMU: the Resettable interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-cpu-topology.html">QAPI interface for S390 CPU topology</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-dasd-ipl.html">Booting from real channel-attached devices on s390x</a></li>
<li class="toctree-l3"><a class="reference internal" href="tracing.html">Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="uefi-vars.html">UEFI variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfio-iommufd.html">IOMMUFD BACKEND usage with VFIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing-monitor-commands.html">How to write monitor commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="virtio-backends.html">Writing VirtIO backends for QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="crypto.html">Cryptography in QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="multiple-iothreads.html">Using Multiple <code class="docutils literal notranslate"><span class="pre">IOThread</span></code>s</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index-tcg.html">TCG Emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="codebase.html">Codebase</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #802400" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QEMU</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Developer Information</a> &raquo;</li>
          <li><a href="index-internals.html">Internal Subsystem Information</a> &raquo;</li>
      <li>The QEMU Object Model (QOM)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="https://gitlab.com/qemu-project/qemu/-/blob/master/docs/devel/qom.rst">View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="the-qemu-object-model-qom">
<span id="qom"></span><h1>The QEMU Object Model (QOM)<a class="headerlink" href="#the-qemu-object-model-qom" title="Permalink to this headline"></a></h1>
<p>The QEMU Object Model provides a framework for registering user creatable
types and instantiating objects from those types.  QOM provides the following
features:</p>
<ul class="simple">
<li><p>System for dynamically registering types</p></li>
<li><p>Support for single-inheritance of types</p></li>
<li><p>Multiple inheritance of stateless interfaces</p></li>
<li><p>Mapping internal members to publicly exposed properties</p></li>
</ul>
<p>The root object class is TYPE_OBJECT which provides for the basic
object methods.</p>
<section id="the-qom-tree">
<h2>The QOM tree<a class="headerlink" href="#the-qom-tree" title="Permalink to this headline"></a></h2>
<p>The QOM tree is a composition tree which represents all of the objects
that make up a QEMU “machine”. You can view this tree by running
<code class="docutils literal notranslate"><span class="pre">info</span> <span class="pre">qom-tree</span></code> in the <a class="reference internal" href="../system/monitor.html#qemu-monitor"><span class="std std-ref">QEMU Monitor</span></a>. It will contain both
objects created by the machine itself as well those created due to
user configuration.</p>
</section>
<section id="creating-a-qom-class">
<h2>Creating a QOM class<a class="headerlink" href="#creating-a-qom-class" title="Permalink to this headline"></a></h2>
<p>A simple minimal device implementation may look something like below:</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">Creating a minimal type</span><a class="headerlink" href="#id2" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;qdev.h&quot;</span>

<span class="cp">#define TYPE_MY_DEVICE &quot;my-device&quot;</span>

<span class="c1">// No new virtual functions: we can reuse the typedef for the</span>
<span class="c1">// superclass.</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">DeviceClass</span><span class="w"> </span><span class="n">MyDeviceClass</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">MyDevice</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">DeviceState</span><span class="w"> </span><span class="n">parent_obj</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">reg0</span><span class="p">,</span><span class="w"> </span><span class="n">reg1</span><span class="p">,</span><span class="w"> </span><span class="n">reg2</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyDevice</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TypeInfo</span><span class="w"> </span><span class="n">my_device_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_MY_DEVICE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_DEVICE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_device_register_types</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">type_register_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_device_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">type_init</span><span class="p">(</span><span class="n">my_device_register_types</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>In the above example, we create a simple type that is described by #TypeInfo.
#TypeInfo describes information about the type including what it inherits
from, the instance and class size, and constructor/destructor hooks.</p>
<p>The TYPE_DEVICE class is the parent class for all modern devices
implemented in QEMU and adds some specific methods to handle QEMU
device model. This includes managing the lifetime of devices from
creation through to when they become visible to the guest and
eventually unrealized.</p>
<p>Alternatively several static types could be registered using helper macro
DEFINE_TYPES()</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TypeInfo</span><span class="w"> </span><span class="n">device_types_info</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_MY_DEVICE_A</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_DEVICE</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyDeviceA</span><span class="p">),</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_MY_DEVICE_B</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_DEVICE</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyDeviceB</span><span class="p">),</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>

<span class="n">DEFINE_TYPES</span><span class="p">(</span><span class="n">device_types_info</span><span class="p">)</span>
</pre></div>
</div>
<p>Every type has an #ObjectClass associated with it.  #ObjectClass derivatives
are instantiated dynamically but there is only ever one instance for any
given type.  The #ObjectClass typically holds a table of function pointers
for the virtual methods implemented by this type.</p>
<p>Using object_new(), a new #Object derivative will be instantiated.  You can
cast an #Object to a subclass (or base-class) type using
object_dynamic_cast().  You typically want to define macro wrappers around
OBJECT_CHECK() and OBJECT_CLASS_CHECK() to make it easier to convert to a
specific type:</p>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption"><span class="caption-text">Typecasting macros</span><a class="headerlink" href="#id3" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MY_DEVICE_GET_CLASS(obj) \</span>
<span class="cp">   OBJECT_GET_CLASS(MyDeviceClass, obj, TYPE_MY_DEVICE)</span>
<span class="cp">#define MY_DEVICE_CLASS(klass) \</span>
<span class="cp">   OBJECT_CLASS_CHECK(MyDeviceClass, klass, TYPE_MY_DEVICE)</span>
<span class="cp">#define MY_DEVICE(obj) \</span>
<span class="cp">   OBJECT_CHECK(MyDevice, obj, TYPE_MY_DEVICE)</span>
</pre></div>
</div>
</div>
<p>In case the ObjectClass implementation can be built as module a
module_obj() line must be added to make sure qemu loads the module
when the object is needed.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">module_obj</span><span class="p">(</span><span class="n">TYPE_MY_DEVICE</span><span class="p">);</span>
</pre></div>
</div>
<section id="class-initialization">
<h3>Class Initialization<a class="headerlink" href="#class-initialization" title="Permalink to this headline"></a></h3>
<p>Before an object is initialized, the class for the object must be
initialized.  There is only one class object for all instance objects
that is created lazily.</p>
<p>Classes are initialized by first initializing any parent classes (if
necessary).  After the parent class object has initialized, it will be
copied into the current class object and any additional storage in the
class object is zero filled.</p>
<p>The effect of this is that classes automatically inherit any virtual
function pointers that the parent class has already initialized.  All
other fields will be zero filled.</p>
<p>Once all of the parent classes have been initialized, #TypeInfo::class_init
is called to let the class being instantiated provide default initialize for
its virtual functions.  Here is how the above example might be modified
to introduce an overridden virtual function:</p>
<div class="literal-block-wrapper docutils container" id="id4">
<div class="code-block-caption"><span class="caption-text">Overriding a virtual function</span><a class="headerlink" href="#id4" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;qdev.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">my_device_class_init</span><span class="p">(</span><span class="n">ObjectClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">class_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">DeviceClass</span><span class="w"> </span><span class="o">*</span><span class="n">dc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEVICE_CLASS</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>
<span class="w">    </span><span class="n">dc</span><span class="o">-&gt;</span><span class="n">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_device_reset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TypeInfo</span><span class="w"> </span><span class="n">my_device_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_MY_DEVICE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_DEVICE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">class_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_device_class_init</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>Introducing new virtual methods requires a class to define its own
struct and to add a .class_size member to the #TypeInfo.  Each method
will also have a wrapper function to call it easily:</p>
<div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption"><span class="caption-text">Defining an abstract class</span><a class="headerlink" href="#id5" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;qdev.h&quot;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">MyDeviceClass</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">DeviceClass</span><span class="w"> </span><span class="n">parent_class</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">frobnicate</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">MyDevice</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyDeviceClass</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TypeInfo</span><span class="w"> </span><span class="n">my_device_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_MY_DEVICE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_DEVICE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">abstract</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="c1">// or set a default in my_device_class_init</span>
<span class="w">    </span><span class="p">.</span><span class="n">class_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyDeviceClass</span><span class="p">),</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">my_device_frobnicate</span><span class="p">(</span><span class="n">MyDevice</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MyDeviceClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_DEVICE_GET_CLASS</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="w">    </span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">frobnicate</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="interfaces">
<h3>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline"></a></h3>
<p>Interfaces allow a limited form of multiple inheritance.  Instances are
similar to normal types except for the fact that are only defined by
their classes and never carry any state.  As a consequence, a pointer to
an interface instance should always be of incomplete type in order to be
sure it cannot be dereferenced.  That is, you should define the
‘typedef struct SomethingIf SomethingIf’ so that you can pass around
<code class="docutils literal notranslate"><span class="pre">SomethingIf</span> <span class="pre">*si</span></code> arguments, but not define a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">SomethingIf</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>.
The only things you can validly do with a <code class="docutils literal notranslate"><span class="pre">SomethingIf</span> <span class="pre">*</span></code> are to pass it as
an argument to a method on its corresponding SomethingIfClass, or to
dynamically cast it to an object that implements the interface.</p>
</section>
<section id="methods">
<h3>Methods<a class="headerlink" href="#methods" title="Permalink to this headline"></a></h3>
<p>A <em>method</em> is a function within the namespace scope of
a class. It usually operates on the object instance by passing it as a
strongly-typed first argument.
If it does not operate on an object instance, it is dubbed
<em>class method</em>.</p>
<p>Methods cannot be overloaded. That is, the #ObjectClass and method name
uniquely identity the function to be called; the signature does not vary
except for trailing varargs.</p>
<p>Methods are always <em>virtual</em>. Overriding a method in
#TypeInfo.class_init of a subclass leads to any user of the class obtained
via OBJECT_GET_CLASS() accessing the overridden function.
The original function is not automatically invoked. It is the responsibility
of the overriding class to determine whether and when to invoke the method
being overridden.</p>
<p>To invoke the method being overridden, the preferred solution is to store
the original value in the overriding class before overriding the method.
This corresponds to <code class="docutils literal notranslate"><span class="pre">{super,base}.method(...)</span></code> in Java and C#
respectively; this frees the overriding class from hardcoding its parent
class, which someone might choose to change at some point.</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">Overriding a virtual method</span><a class="headerlink" href="#id6" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">MyState</span><span class="w"> </span><span class="n">MyState</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">MyDoSomething</span><span class="p">)(</span><span class="n">MyState</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">);</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ObjectClass</span><span class="w"> </span><span class="n">parent_class</span><span class="p">;</span>

<span class="w">    </span><span class="n">MyDoSomething</span><span class="w"> </span><span class="n">do_something</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">MyClass</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_do_something</span><span class="p">(</span><span class="n">MyState</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// do something</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_class_init</span><span class="p">(</span><span class="n">ObjectClass</span><span class="w"> </span><span class="o">*</span><span class="n">oc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MyClass</span><span class="w"> </span><span class="o">*</span><span class="n">mc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_CLASS</span><span class="p">(</span><span class="n">oc</span><span class="p">);</span>

<span class="w">    </span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_do_something</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TypeInfo</span><span class="w"> </span><span class="n">my_type_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_MY</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_OBJECT</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyState</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">class_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyClass</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">class_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_class_init</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">DerivedClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MyClass</span><span class="w"> </span><span class="n">parent_class</span><span class="p">;</span>

<span class="w">    </span><span class="n">MyDoSomething</span><span class="w"> </span><span class="n">parent_do_something</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">DerivedClass</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">derived_do_something</span><span class="p">(</span><span class="n">MyState</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">DerivedClass</span><span class="w"> </span><span class="o">*</span><span class="n">dc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DERIVED_GET_CLASS</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// do something here</span>
<span class="w">    </span><span class="n">dc</span><span class="o">-&gt;</span><span class="n">parent_do_something</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// do something else here</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">derived_class_init</span><span class="p">(</span><span class="n">ObjectClass</span><span class="w"> </span><span class="o">*</span><span class="n">oc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MyClass</span><span class="w"> </span><span class="o">*</span><span class="n">mc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MY_CLASS</span><span class="p">(</span><span class="n">oc</span><span class="p">);</span>
<span class="w">    </span><span class="n">DerivedClass</span><span class="w"> </span><span class="o">*</span><span class="n">dc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DERIVED_CLASS</span><span class="p">(</span><span class="n">oc</span><span class="p">);</span>

<span class="w">    </span><span class="n">dc</span><span class="o">-&gt;</span><span class="n">parent_do_something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">;</span>
<span class="w">    </span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">derived_do_something</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TypeInfo</span><span class="w"> </span><span class="n">derived_type_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_DERIVED</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_MY</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">class_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">DerivedClass</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">class_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">derived_class_init</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>Alternatively, object_class_by_name() can be used to obtain the class and
its non-overridden methods for a specific type. This would correspond to
<code class="docutils literal notranslate"><span class="pre">MyClass::method(...)</span></code> in C++.</p>
<p>One example of such methods is <code class="docutils literal notranslate"><span class="pre">DeviceClass.reset</span></code>. More examples
can be found at <a class="reference internal" href="#device-life-cycle"><span class="std std-ref">Device Life-cycle</span></a>.</p>
</section>
</section>
<section id="standard-type-declaration-and-definition-macros">
<h2>Standard type declaration and definition macros<a class="headerlink" href="#standard-type-declaration-and-definition-macros" title="Permalink to this headline"></a></h2>
<p>A lot of the code outlined above follows a standard pattern and naming
convention. To reduce the amount of boilerplate code that needs to be
written for a new type there are two sets of macros to generate the
common parts in a standard format.</p>
<p>A type is declared using the OBJECT_DECLARE macro family. In types
which do not require any virtual functions in the class, the
OBJECT_DECLARE_SIMPLE_TYPE macro is suitable, and is commonly placed
in the header file:</p>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">Declaring a simple type</span><a class="headerlink" href="#id7" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OBJECT_DECLARE_SIMPLE_TYPE</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span><span class="w"> </span><span class="n">MY_DEVICE</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>This is equivalent to the following:</p>
<div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-text">Expansion from declaring a simple type</span><a class="headerlink" href="#id8" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">MyDevice</span><span class="w"> </span><span class="n">MyDevice</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">MyDeviceClass</span><span class="w"> </span><span class="n">MyDeviceClass</span><span class="p">;</span>

<span class="n">G_DEFINE_AUTOPTR_CLEANUP_FUNC</span><span class="p">(</span><span class="n">MyDeviceClass</span><span class="p">,</span><span class="w"> </span><span class="n">object_unref</span><span class="p">)</span>

<span class="cp">#define MY_DEVICE_GET_CLASS(void *obj) \</span>
<span class="cp">        OBJECT_GET_CLASS(MyDeviceClass, obj, TYPE_MY_DEVICE)</span>
<span class="cp">#define MY_DEVICE_CLASS(void *klass) \</span>
<span class="cp">        OBJECT_CLASS_CHECK(MyDeviceClass, klass, TYPE_MY_DEVICE)</span>
<span class="cp">#define MY_DEVICE(void *obj)</span>
<span class="w">        </span><span class="n">OBJECT_CHECK</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">TYPE_MY_DEVICE</span><span class="p">)</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MyDeviceClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">DeviceClass</span><span class="w"> </span><span class="n">parent_class</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>The ‘struct MyDevice’ needs to be declared separately.
If the type requires virtual functions to be declared in the class
struct, then the alternative OBJECT_DECLARE_TYPE() macro can be
used. This does the same as OBJECT_DECLARE_SIMPLE_TYPE(), but without
the ‘struct MyDeviceClass’ definition.</p>
<p>To implement the type, the OBJECT_DEFINE macro family is available.
For the simplest case of a leaf class which doesn’t need any of its
own virtual functions (i.e. which was declared with OBJECT_DECLARE_SIMPLE_TYPE)
the OBJECT_DEFINE_SIMPLE_TYPE macro is suitable:</p>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">Defining a simple type</span><a class="headerlink" href="#id9" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OBJECT_DEFINE_SIMPLE_TYPE</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span><span class="w"> </span><span class="n">my_device</span><span class="p">,</span><span class="w"> </span><span class="n">MY_DEVICE</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>This is equivalent to the following:</p>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption"><span class="caption-text">Expansion from defining a simple type</span><a class="headerlink" href="#id10" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_device_finalize</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_device_class_init</span><span class="p">(</span><span class="n">ObjectClass</span><span class="w"> </span><span class="o">*</span><span class="n">oc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_device_init</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">TypeInfo</span><span class="w"> </span><span class="n">my_device_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_DEVICE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TYPE_MY_DEVICE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">instance_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_device_init</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">instance_finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_device_finalize</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">class_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_device_class_init</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">my_device_register_types</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">type_register_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_device_info</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">type_init</span><span class="p">(</span><span class="n">my_device_register_types</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>This is sufficient to get the type registered with the type
system, and the three standard methods now need to be implemented
along with any other logic required for the type.</p>
<p>If the class needs its own virtual methods, or has some other
per-class state it needs to store in its own class struct,
then you can use the OBJECT_DEFINE_TYPE macro. This does the
same thing as OBJECT_DEFINE_SIMPLE_TYPE, but it also sets the
class_size of the type to the size of the class struct.</p>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">Defining a type which needs a class struct</span><a class="headerlink" href="#id11" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OBJECT_DEFINE_TYPE</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span><span class="w"> </span><span class="n">my_device</span><span class="p">,</span><span class="w"> </span><span class="n">MY_DEVICE</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>If the type needs to implement one or more interfaces, then the
OBJECT_DEFINE_SIMPLE_TYPE_WITH_INTERFACES() and
OBJECT_DEFINE_TYPE_WITH_INTERFACES() macros can be used instead.
These accept an array of interface type names. The difference between
them is that the former is for simple leaf classes that don’t need
a class struct, and the latter is for when you will be defining
a class struct.</p>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">Defining a simple type implementing interfaces</span><a class="headerlink" href="#id12" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OBJECT_DEFINE_SIMPLE_TYPE_WITH_INTERFACES</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span><span class="w"> </span><span class="n">my_device</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">MY_DEVICE</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="p">,</span>
<span class="w">                                          </span><span class="p">{</span><span class="w"> </span><span class="n">TYPE_USER_CREATABLE</span><span class="w"> </span><span class="p">},</span>
<span class="w">                                          </span><span class="p">{</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-text">Defining a type implementing interfaces</span><a class="headerlink" href="#id13" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OBJECT_DEFINE_TYPE_WITH_INTERFACES</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span><span class="w"> </span><span class="n">my_device</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">MY_DEVICE</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="p">,</span>
<span class="w">                                   </span><span class="p">{</span><span class="w"> </span><span class="n">TYPE_USER_CREATABLE</span><span class="w"> </span><span class="p">},</span>
<span class="w">                                   </span><span class="p">{</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">})</span>
</pre></div>
</div>
</div>
<p>If the type is not intended to be instantiated, then the
OBJECT_DEFINE_ABSTRACT_TYPE() macro can be used instead:</p>
<div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">Defining a simple abstract type</span><a class="headerlink" href="#id14" title="Permalink to this code"></a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">OBJECT_DEFINE_ABSTRACT_TYPE</span><span class="p">(</span><span class="n">MyDevice</span><span class="p">,</span><span class="w"> </span><span class="n">my_device</span><span class="p">,</span>
<span class="w">                            </span><span class="n">MY_DEVICE</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="device-life-cycle">
<span id="id1"></span><h2>Device Life-cycle<a class="headerlink" href="#device-life-cycle" title="Permalink to this headline"></a></h2>
<p>As class initialisation cannot fail devices have an two additional
methods to handle the creation of dynamic devices. The <code class="docutils literal notranslate"><span class="pre">realize</span></code>
function is called with <code class="docutils literal notranslate"><span class="pre">Error</span> <span class="pre">**</span></code> pointer which should be set if
the device cannot complete its setup. Otherwise on successful
completion of the <code class="docutils literal notranslate"><span class="pre">realize</span></code> method the device object is added to the
QOM tree and made visible to the guest.</p>
<p>The reverse function is <code class="docutils literal notranslate"><span class="pre">unrealize</span></code> and should be were clean-up
code lives to tidy up after the system is done with the device.</p>
<p>All devices can be instantiated by C code, however only some can
created dynamically via the command line or monitor.</p>
<p>Likewise only some can be unplugged after creation and need an
explicit <code class="docutils literal notranslate"><span class="pre">unrealize</span></code> implementation. This is determined by the
<code class="docutils literal notranslate"><span class="pre">user_creatable</span></code> variable in the root <code class="docutils literal notranslate"><span class="pre">DeviceClass</span></code> structure.
Devices can only be unplugged if their <code class="docutils literal notranslate"><span class="pre">parent_bus</span></code> has a registered
<code class="docutils literal notranslate"><span class="pre">HotplugHandler</span></code>.</p>
</section>
<section id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline"></a></h2>
<p>See the <a class="reference internal" href="qom-api.html#qom-api"><span class="std std-ref">QOM API</span></a> and <a class="reference internal" href="qdev-api.html#qdev-api"><span class="std std-ref">QDEV API</span></a>
documents for the complete API description.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index-internals.html" class="btn btn-neutral float-left" title="Internal Subsystem Information" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="atomics.html" class="btn btn-neutral float-right" title="Atomic operations in QEMU" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, The QEMU Project Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  

<!-- Empty para to force a blank line after "Built with Sphinx ..." -->
<p></p>

<p>This documentation is for QEMU version 10.0.50.</p>


<p><a href="../about/license.html">QEMU and this manual are released under the
GNU General Public License, version 2.</a></p>

 


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>