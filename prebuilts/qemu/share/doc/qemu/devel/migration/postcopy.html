<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Postcopy &mdash; QEMU  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/qemu_32x32.png"/>
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/custom.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Dirty limit" href="dirty-limit.html" />
    <link rel="prev" title="Migration features" href="features.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #802400" >
            <a href="../../index.html" class="icon icon-home"> QEMU
            <img src="../../_static/qemu_128x128.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                10.0.50
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../about/index.html">About QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../system/index.html">System Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/index.html">User Mode Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../interop/index.html">System Emulation Management and Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../specs/index.html">System Emulation Guest Hardware Specifications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Developer Information</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index-process.html">QEMU Community Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index-build.html">QEMU Build System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/index.html">Testing QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index-api.html">Internal QEMU APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index-internals.html">Internal Subsystem Information</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../qom.html">The QEMU Object Model (QOM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../atomics.html">Atomic operations in QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rcu.html">Using RCU (Read-Copy-Update) for synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../block-coroutine-wrapper.html">block-coroutine-wrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../clocks.html">Modelling a clock tree in QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ebpf_rss.html">eBPF RSS virtio-net support</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Migration</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="main.html">Migration framework</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="features.html">Migration features</a></li>
<li class="toctree-l4"><a class="reference internal" href="compatibility.html">Backwards compatibility</a></li>
<li class="toctree-l4"><a class="reference internal" href="best-practices.html">Best practices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../multi-process.html">Multi-process QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reset.html">Reset in QEMU: the Resettable interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../s390-cpu-topology.html">QAPI interface for S390 CPU topology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../s390-dasd-ipl.html">Booting from real channel-attached devices on s390x</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tracing.html">Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../uefi-vars.html">UEFI variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../vfio-iommufd.html">IOMMUFD BACKEND usage with VFIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="../writing-monitor-commands.html">How to write monitor commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="../virtio-backends.html">Writing VirtIO backends for QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto.html">Cryptography in QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../multiple-iothreads.html">Using Multiple <code class="docutils literal notranslate"><span class="pre">IOThread</span></code>s</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index-tcg.html">TCG Emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../codebase.html">Codebase</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #802400" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">QEMU</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Developer Information</a> &raquo;</li>
          <li><a href="../index-internals.html">Internal Subsystem Information</a> &raquo;</li>
          <li><a href="index.html">Migration</a> &raquo;</li>
          <li><a href="features.html">Migration features</a> &raquo;</li>
      <li>Postcopy</li>
      <li class="wy-breadcrumbs-aside">
            <a href="https://gitlab.com/qemu-project/qemu/-/blob/master/docs/devel/migration/postcopy.rst">View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="postcopy">
<h1><a class="toc-backref" href="#id1" role="doc-backlink">Postcopy</a><a class="headerlink" href="#postcopy" title="Permalink to this headline"></a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#postcopy" id="id1">Postcopy</a></p>
<ul>
<li><p><a class="reference internal" href="#enabling-postcopy" id="id2">Enabling postcopy</a></p></li>
<li><p><a class="reference internal" href="#postcopy-internals" id="id3">Postcopy internals</a></p>
<ul>
<li><p><a class="reference internal" href="#state-machine" id="id4">State machine</a></p></li>
<li><p><a class="reference internal" href="#device-transfer" id="id5">Device transfer</a></p></li>
<li><p><a class="reference internal" href="#source-behaviour" id="id6">Source behaviour</a></p></li>
<li><p><a class="reference internal" href="#destination-behaviour" id="id7">Destination behaviour</a></p></li>
<li><p><a class="reference internal" href="#source-side-page-bitmap" id="id8">Source side page bitmap</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#postcopy-features" id="id9">Postcopy features</a></p>
<ul>
<li><p><a class="reference internal" href="#postcopy-recovery" id="id10">Postcopy recovery</a></p></li>
<li><p><a class="reference internal" href="#postcopy-with-hugepages" id="id11">Postcopy with hugepages</a></p></li>
<li><p><a class="reference internal" href="#postcopy-with-shared-memory" id="id12">Postcopy with shared memory</a></p></li>
<li><p><a class="reference internal" href="#postcopy-preemption-mode" id="id13">Postcopy preemption mode</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<p>‘Postcopy’ migration is a way to deal with migrations that refuse to converge
(or take too long to converge) its plus side is that there is an upper bound on
the amount of migration traffic and time it takes, the down side is that during
the postcopy phase, a failure of <em>either</em> side causes the guest to be lost.</p>
<p>In postcopy the destination CPUs are started before all the memory has been
transferred, and accesses to pages that are yet to be transferred cause
a fault that’s translated by QEMU into a request to the source QEMU.</p>
<p>Postcopy can be combined with precopy (i.e. normal migration) so that if precopy
doesn’t finish in a given time the switch is made to postcopy.</p>
<section id="enabling-postcopy">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Enabling postcopy</a><a class="headerlink" href="#enabling-postcopy" title="Permalink to this headline"></a></h2>
<p>To enable postcopy, issue this command on the monitor (both source and
destination) prior to the start of migration:</p>
<p><code class="docutils literal notranslate"><span class="pre">migrate_set_capability</span> <span class="pre">postcopy-ram</span> <span class="pre">on</span></code></p>
<p>The normal commands are then used to start a migration, which is still
started in precopy mode.  Issuing:</p>
<p><code class="docutils literal notranslate"><span class="pre">migrate_start_postcopy</span></code></p>
<p>will now cause the transition from precopy to postcopy.
It can be issued immediately after migration is started or any
time later on.  Issuing it after the end of a migration is harmless.</p>
<p>Blocktime is a postcopy live migration metric, intended to show how
long the vCPU was in state of interruptible sleep due to pagefault.
That metric is calculated both for all vCPUs as overlapped value, and
separately for each vCPU. These values are calculated on destination
side.  To enable postcopy blocktime calculation, enter following
command on destination monitor:</p>
<p><code class="docutils literal notranslate"><span class="pre">migrate_set_capability</span> <span class="pre">postcopy-blocktime</span> <span class="pre">on</span></code></p>
<p>Postcopy blocktime can be retrieved by query-migrate qmp command.
postcopy-blocktime value of qmp command will show overlapped blocking
time for all vCPU, postcopy-vcpu-blocktime will show list of blocking
time per vCPU.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>During the postcopy phase, the bandwidth limits set using
<code class="docutils literal notranslate"><span class="pre">migrate_set_parameter</span></code> is ignored (to avoid delaying requested pages that
the destination is waiting for).</p>
</aside>
</section>
<section id="postcopy-internals">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Postcopy internals</a><a class="headerlink" href="#postcopy-internals" title="Permalink to this headline"></a></h2>
<section id="state-machine">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">State machine</a><a class="headerlink" href="#state-machine" title="Permalink to this headline"></a></h3>
<p>Postcopy moves through a series of states (see postcopy_state) from
ADVISE-&gt;DISCARD-&gt;LISTEN-&gt;RUNNING-&gt;END</p>
<blockquote>
<div><ul>
<li><p>Advise</p>
<blockquote>
<div><p>Set at the start of migration if postcopy is enabled, even
if it hasn’t had the start command; here the destination
checks that its OS has the support needed for postcopy, and performs
setup to ensure the RAM mappings are suitable for later postcopy.
The destination will fail early in migration at this point if the
required OS support is not present.
(Triggered by reception of POSTCOPY_ADVISE command)</p>
</div></blockquote>
</li>
<li><p>Discard</p>
<blockquote>
<div><p>Entered on receipt of the first ‘discard’ command; prior to
the first Discard being performed, hugepages are switched off
(using madvise) to ensure that no new huge pages are created
during the postcopy phase, and to cause any huge pages that
have discards on them to be broken.</p>
</div></blockquote>
</li>
<li><p>Listen</p>
<blockquote>
<div><p>The first command in the package, POSTCOPY_LISTEN, switches
the destination state to Listen, and starts a new thread
(the ‘listen thread’) which takes over the job of receiving
pages off the migration stream, while the main thread carries
on processing the blob.  With this thread able to process page
reception, the destination now ‘sensitises’ the RAM to detect
any access to missing pages (on Linux using the ‘userfault’
system).</p>
</div></blockquote>
</li>
<li><p>Running</p>
<blockquote>
<div><p>POSTCOPY_RUN causes the destination to synchronise all
state and start the CPUs and IO devices running.  The main
thread now finishes processing the migration package and
now carries on as it would for normal precopy migration
(although it can’t do the cleanup it would do as it
finishes a normal migration).</p>
</div></blockquote>
</li>
<li><p>End</p>
<blockquote>
<div><p>The listen thread can now quit, and perform the cleanup of migration
state, the migration is now complete.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
<section id="device-transfer">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Device transfer</a><a class="headerlink" href="#device-transfer" title="Permalink to this headline"></a></h3>
<p>Loading of device data may cause the device emulation to access guest RAM
that may trigger faults that have to be resolved by the source, as such
the migration stream has to be able to respond with page data <em>during</em> the
device load, and hence the device data has to be read from the stream completely
before the device load begins to free the stream up.  This is achieved by
‘packaging’ the device data into a blob that’s read in one go.</p>
</section>
<section id="source-behaviour">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Source behaviour</a><a class="headerlink" href="#source-behaviour" title="Permalink to this headline"></a></h3>
<p>Until postcopy is entered the migration stream is identical to normal
precopy, except for the addition of a ‘postcopy advise’ command at
the beginning, to tell the destination that postcopy might happen.
When postcopy starts the source sends the page discard data and then
forms the ‘package’ containing:</p>
<blockquote>
<div><ul>
<li><p>Command: ‘postcopy listen’</p></li>
<li><p>The device state</p>
<p>A series of sections, identical to the precopy streams device state stream
containing everything except postcopiable devices (i.e. RAM)</p>
</li>
<li><p>Command: ‘postcopy run’</p></li>
</ul>
</div></blockquote>
<p>The ‘package’ is sent as the data part of a Command: <code class="docutils literal notranslate"><span class="pre">CMD_PACKAGED</span></code>, and the
contents are formatted in the same way as the main migration stream.</p>
<p>During postcopy the source scans the list of dirty pages and sends them
to the destination without being requested (in much the same way as precopy),
however when a page request is received from the destination, the dirty page
scanning restarts from the requested location.  This causes requested pages
to be sent quickly, and also causes pages directly after the requested page
to be sent quickly in the hope that those pages are likely to be used
by the destination soon.</p>
</section>
<section id="destination-behaviour">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Destination behaviour</a><a class="headerlink" href="#destination-behaviour" title="Permalink to this headline"></a></h3>
<p>Initially the destination looks the same as precopy, with a single thread
reading the migration stream; the ‘postcopy advise’ and ‘discard’ commands
are processed to change the way RAM is managed, but don’t affect the stream
processing.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">------------------------------------------------------------------------------</span>
                        <span class="mi">1</span>      <span class="mi">2</span>   <span class="mi">3</span>     <span class="mi">4</span> <span class="mi">5</span>                      <span class="mi">6</span>   <span class="mi">7</span>
<span class="n">main</span> <span class="o">-----</span><span class="n">DISCARD</span><span class="o">-</span><span class="n">CMD_PACKAGED</span> <span class="p">(</span> <span class="n">LISTEN</span>  <span class="n">DEVICE</span>     <span class="n">DEVICE</span> <span class="n">DEVICE</span> <span class="n">RUN</span> <span class="p">)</span>
<span class="n">thread</span>                             <span class="o">|</span>       <span class="o">|</span>
                                   <span class="o">|</span>     <span class="p">(</span><span class="n">page</span> <span class="n">request</span><span class="p">)</span>
                                   <span class="o">|</span>        \<span class="n">___</span>
                                   <span class="n">v</span>            \
<span class="n">listen</span> <span class="n">thread</span><span class="p">:</span>                     <span class="o">---</span> <span class="n">page</span> <span class="o">--</span> <span class="n">page</span> <span class="o">--</span> <span class="n">page</span> <span class="o">--</span> <span class="n">page</span> <span class="o">--</span> <span class="n">page</span> <span class="o">--</span>

                                   <span class="n">a</span>   <span class="n">b</span>        <span class="n">c</span>
<span class="o">------------------------------------------------------------------------------</span>
</pre></div>
</div>
<ul>
<li><p>On receipt of <code class="docutils literal notranslate"><span class="pre">CMD_PACKAGED</span></code> (1)</p>
<blockquote>
<div><p>All the data associated with the package - the ( … ) section in the diagram -
is read into memory, and the main thread recurses into qemu_loadvm_state_main
to process the contents of the package (2) which contains commands (3,6) and
devices (4…)</p>
</div></blockquote>
</li>
<li><p>On receipt of ‘postcopy listen’ - 3 -(i.e. the 1st command in the package)</p>
<blockquote>
<div><p>a new thread (a) is started that takes over servicing the migration stream,
while the main thread carries on loading the package.   It loads normal
background page data (b) but if during a device load a fault happens (5)
the returned page (c) is loaded by the listen thread allowing the main
threads device load to carry on.</p>
</div></blockquote>
</li>
<li><p>The last thing in the <code class="docutils literal notranslate"><span class="pre">CMD_PACKAGED</span></code> is a ‘RUN’ command (6)</p>
<blockquote>
<div><p>letting the destination CPUs start running.  At the end of the
<code class="docutils literal notranslate"><span class="pre">CMD_PACKAGED</span></code> (7) the main thread returns to normal running behaviour and
is no longer used by migration, while the listen thread carries on servicing
page data until the end of migration.</p>
</div></blockquote>
</li>
</ul>
</section>
<section id="source-side-page-bitmap">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Source side page bitmap</a><a class="headerlink" href="#source-side-page-bitmap" title="Permalink to this headline"></a></h3>
<p>The ‘migration bitmap’ in postcopy is basically the same as in the precopy,
where each of the bit to indicate that page is ‘dirty’ - i.e. needs
sending.  During the precopy phase this is updated as the CPU dirties
pages, however during postcopy the CPUs are stopped and nothing should
dirty anything any more. Instead, dirty bits are cleared when the relevant
pages are sent during postcopy.</p>
</section>
</section>
<section id="postcopy-features">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Postcopy features</a><a class="headerlink" href="#postcopy-features" title="Permalink to this headline"></a></h2>
<section id="postcopy-recovery">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Postcopy recovery</a><a class="headerlink" href="#postcopy-recovery" title="Permalink to this headline"></a></h3>
<p>Comparing to precopy, postcopy is special on error handlings.  When any
error happens (in this case, mostly network errors), QEMU cannot easily
fail a migration because VM data resides in both source and destination
QEMU instances.  On the other hand, when issue happens QEMU on both sides
will go into a paused state.  It’ll need a recovery phase to continue a
paused postcopy migration.</p>
<p>The recovery phase normally contains a few steps:</p>
<blockquote>
<div><ul class="simple">
<li><p>When network issue occurs, both QEMU will go into <strong>POSTCOPY_PAUSED</strong>
migration state.</p></li>
<li><p>When the network is recovered (or a new network is provided), the admin
can setup the new channel for migration using QMP command
‘migrate-recover’ on destination node, preparing for a resume.</p></li>
<li><p>On source host, the admin can continue the interrupted postcopy
migration using QMP command ‘migrate’ with resume=true flag set.
Source QEMU will go into <strong>POSTCOPY_RECOVER_SETUP</strong> state trying to
re-establish the channels.</p></li>
<li><p>When both sides of QEMU successfully reconnect using a new or fixed up
channel, they will go into <strong>POSTCOPY_RECOVER</strong> state, some handshake
procedure will be needed to properly synchronize the VM states between
the two QEMUs to continue the postcopy migration.  For example, there
can be pages sent right during the window when the network is
interrupted, then the handshake will guarantee pages lost in-flight
will be resent again.</p></li>
<li><p>After a proper handshake synchronization, QEMU will continue the
postcopy migration on both sides and go back to <strong>POSTCOPY_ACTIVE</strong>
state.  Postcopy migration will continue.</p></li>
</ul>
</div></blockquote>
<p>During a paused postcopy migration, the VM can logically still continue
running, and it will not be impacted from any page access to pages that
were already migrated to destination VM before the interruption happens.
However, if any of the missing pages got accessed on destination VM, the VM
thread will be halted waiting for the page to be migrated, it means it can
be halted until the recovery is complete.</p>
<p>The impact of accessing missing pages can be relevant to different
configurations of the guest.  For example, when with async page fault
enabled, logically the guest can proactively schedule out the threads
accessing missing pages.</p>
</section>
<section id="postcopy-with-hugepages">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Postcopy with hugepages</a><a class="headerlink" href="#postcopy-with-hugepages" title="Permalink to this headline"></a></h3>
<p>Postcopy now works with hugetlbfs backed memory:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>The linux kernel on the destination must support userfault on hugepages.</p></li>
<li><p>The huge-page configuration on the source and destination VMs must be
identical; i.e. RAMBlocks on both sides must use the same page size.</p></li>
<li><p>Note that <code class="docutils literal notranslate"><span class="pre">-mem-path</span> <span class="pre">/dev/hugepages</span></code>  will fall back to allocating normal
RAM if it doesn’t have enough hugepages, triggering (b) to fail.
Using <code class="docutils literal notranslate"><span class="pre">-mem-prealloc</span></code> enforces the allocation using hugepages.</p></li>
<li><p>Care should be taken with the size of hugepage used; postcopy with 2MB
hugepages works well, however 1GB hugepages are likely to be problematic
since it takes ~1 second to transfer a 1GB hugepage across a 10Gbps link,
and until the full page is transferred the destination thread is blocked.</p></li>
</ol>
</div></blockquote>
</section>
<section id="postcopy-with-shared-memory">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Postcopy with shared memory</a><a class="headerlink" href="#postcopy-with-shared-memory" title="Permalink to this headline"></a></h3>
<p>Postcopy migration with shared memory needs explicit support from the other
processes that share memory and from QEMU. There are restrictions on the type of
memory that userfault can support shared.</p>
<p>The Linux kernel userfault support works on <code class="docutils literal notranslate"><span class="pre">/dev/shm</span></code> memory and on <code class="docutils literal notranslate"><span class="pre">hugetlbfs</span></code>
(although the kernel doesn’t provide an equivalent to <code class="docutils literal notranslate"><span class="pre">madvise(MADV_DONTNEED)</span></code>
for hugetlbfs which may be a problem in some configurations).</p>
<p>The vhost-user code in QEMU supports clients that have Postcopy support,
and the <code class="docutils literal notranslate"><span class="pre">vhost-user-bridge</span></code> (in <code class="docutils literal notranslate"><span class="pre">tests/</span></code>) and the DPDK package have changes
to support postcopy.</p>
<p>The client needs to open a userfaultfd and register the areas
of memory that it maps with userfault.  The client must then pass the
userfaultfd back to QEMU together with a mapping table that allows
fault addresses in the clients address space to be converted back to
RAMBlock/offsets.  The client’s userfaultfd is added to the postcopy
fault-thread and page requests are made on behalf of the client by QEMU.
QEMU performs ‘wake’ operations on the client’s userfaultfd to allow it
to continue after a page has arrived.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>There are two future improvements that would be nice:</dt><dd><ol class="loweralpha simple">
<li><p>Some way to make QEMU ignorant of the addresses in the clients
address space</p></li>
<li><p>Avoiding the need for QEMU to perform ufd-wake calls after the
pages have arrived</p></li>
</ol>
</dd>
</dl>
</aside>
<dl class="simple">
<dt>Retro-fitting postcopy to existing clients is possible:</dt><dd><ol class="loweralpha simple">
<li><p>A mechanism is needed for the registration with userfault as above,
and the registration needs to be coordinated with the phases of
postcopy.  In vhost-user extra messages are added to the existing
control channel.</p></li>
<li><p>Any thread that can block due to guest memory accesses must be
identified and the implication understood; for example if the
guest memory access is made while holding a lock then all other
threads waiting for that lock will also be blocked.</p></li>
</ol>
</dd>
</dl>
</section>
<section id="postcopy-preemption-mode">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Postcopy preemption mode</a><a class="headerlink" href="#postcopy-preemption-mode" title="Permalink to this headline"></a></h3>
<p>Postcopy preempt is a new capability introduced in 8.0 QEMU release, it
allows urgent pages (those got page fault requested from destination QEMU
explicitly) to be sent in a separate preempt channel, rather than queued in
the background migration channel.  Anyone who cares about latencies of page
faults during a postcopy migration should enable this feature.  By default,
it’s not enabled.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="features.html" class="btn btn-neutral float-left" title="Migration features" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="dirty-limit.html" class="btn btn-neutral float-right" title="Dirty limit" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, The QEMU Project Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  

<!-- Empty para to force a blank line after "Built with Sphinx ..." -->
<p></p>

<p>This documentation is for QEMU version 10.0.50.</p>


<p><a href="../../about/license.html">QEMU and this manual are released under the
GNU General Public License, version 2.</a></p>

 


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>