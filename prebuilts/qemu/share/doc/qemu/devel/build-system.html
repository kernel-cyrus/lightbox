<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The QEMU build system architecture &mdash; QEMU  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/qemu_32x32.png"/>
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/custom.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Setup build environment" href="build-environment.html" />
    <link rel="prev" title="QEMU Build System" href="index-build.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #802400" >
            <a href="../index.html" class="icon icon-home"> QEMU
            <img src="../_static/qemu_128x128.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                10.0.50
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">About QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/index.html">System Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User Mode Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interop/index.html">System Emulation Management and Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../specs/index.html">System Emulation Guest Hardware Specifications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Information</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index-process.html">QEMU Community Processes</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index-build.html">QEMU Build System</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">The QEMU build system architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stage-1-configure">Stage 1: configure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stage-2-meson">Stage 2: Meson</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stage-3-make">Stage 3: Make</a></li>
<li class="toctree-l4"><a class="reference internal" href="#important-files-for-the-build-system">Important files for the build system</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-environment.html">Setup build environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="kconfig.html">QEMU and Kconfig</a></li>
<li class="toctree-l3"><a class="reference internal" href="docs.html">QEMU Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="qapi-code-gen.html">How to use the QAPI code generator</a></li>
<li class="toctree-l3"><a class="reference internal" href="qapi-domain.html">The Sphinx QAPI Domain</a></li>
<li class="toctree-l3"><a class="reference internal" href="control-flow-integrity.html">Control-Flow Integrity (CFI)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="testing/index.html">Testing QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-api.html">Internal QEMU APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-internals.html">Internal Subsystem Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-tcg.html">TCG Emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="codebase.html">Codebase</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #802400" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QEMU</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Developer Information</a> &raquo;</li>
          <li><a href="index-build.html">QEMU Build System</a> &raquo;</li>
      <li>The QEMU build system architecture</li>
      <li class="wy-breadcrumbs-aside">
            <a href="https://gitlab.com/qemu-project/qemu/-/blob/master/docs/devel/build-system.rst">View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="the-qemu-build-system-architecture">
<h1>The QEMU build system architecture<a class="headerlink" href="#the-qemu-build-system-architecture" title="Permalink to this headline"></a></h1>
<p>This document aims to help developers understand the architecture of the
QEMU build system. As with projects using GNU autotools, the QEMU build
system has two stages; first the developer runs the “configure” script
to determine the local build environment characteristics, then they run
“make” to build the project.  This is about where the similarities with
GNU autotools end, so try to forget what you know about them.</p>
<p>The two general ways to perform a build are as follows:</p>
<blockquote>
<div><ul>
<li><p>build artifacts outside of QEMU source tree entirely:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">../</span>
<span class="n">mkdir</span> <span class="n">build</span>
<span class="n">cd</span> <span class="n">build</span>
<span class="o">../</span><span class="n">qemu</span><span class="o">/</span><span class="n">configure</span>
<span class="n">make</span>
</pre></div>
</div>
</li>
<li><p>build artifacts in a subdir of QEMU source tree:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mkdir</span> <span class="n">build</span>
<span class="n">cd</span> <span class="n">build</span>
<span class="o">../</span><span class="n">configure</span>
<span class="n">make</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>Most of the actual build process uses Meson under the hood, therefore
build artifacts cannot be placed in the source tree itself.</p>
<section id="stage-1-configure">
<h2>Stage 1: configure<a class="headerlink" href="#stage-1-configure" title="Permalink to this headline"></a></h2>
<p>The configure script has five tasks:</p>
<blockquote>
<div><ul class="simple">
<li><p>detect the host architecture</p></li>
<li><p>list the targets for which to build emulators; the list of
targets also affects which firmware binaries and tests to build</p></li>
<li><p>find the compilers (native and cross) used to build executables,
firmware and tests.  The results are written as either Makefile
fragments (<code class="docutils literal notranslate"><span class="pre">config-host.mak</span></code>) or a Meson machine file
(<code class="docutils literal notranslate"><span class="pre">config-meson.cross</span></code>)</p></li>
<li><p>create a virtual environment in which all Python code runs during
the build, and possibly install packages into it from PyPI</p></li>
<li><p>invoke Meson in the virtual environment, to perform the actual
configuration step for the emulator build</p></li>
</ul>
</div></blockquote>
<p>The configure script automatically recognizes command line options for
which a same-named Meson option exists; dashes in the command line are
replaced with underscores.</p>
<p>Almost all QEMU developers that need to modify the build system will
only be concerned with Meson, and therefore can skip the rest of this
section.</p>
<section id="modifying-configure">
<h3>Modifying <code class="docutils literal notranslate"><span class="pre">configure</span></code><a class="headerlink" href="#modifying-configure" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">configure</span></code> is a shell script; it uses <code class="docutils literal notranslate"><span class="pre">#!/bin/sh</span></code> and therefore
should be compatible with any POSIX shell. It is important to avoid
using bash-isms to avoid breaking development platforms where bash is
the primary host.</p>
<p>The configure script provides a variety of functions to help writing
portable shell code and providing consistent behavior across architectures
and operating systems:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">error_exit</span> <span class="pre">$MESSAGE</span> <span class="pre">$MORE...</span></code></dt><dd><p>Print $MESSAGE to stderr, followed by $MORE… and then exit from the
configure script with non-zero status.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">has</span> <span class="pre">$COMMAND</span></code></dt><dd><p>Determine if $COMMAND exists in the current environment, either as a
shell builtin, or executable binary, returning 0 on success.  The
replacement in Meson is <code class="docutils literal notranslate"><span class="pre">find_program()</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_target_compiler</span> <span class="pre">$TARGET</span></code></dt><dd><p>Detect a cross compiler and cross tools for the QEMU target $TARGET (e.g.,
<code class="docutils literal notranslate"><span class="pre">$CPU-softmmu</span></code>, <code class="docutils literal notranslate"><span class="pre">$CPU-linux-user</span></code>, <code class="docutils literal notranslate"><span class="pre">$CPU-bsd-user</span></code>).  If a working
compiler is present, return success and set variables <code class="docutils literal notranslate"><span class="pre">$target_cc</span></code>,
<code class="docutils literal notranslate"><span class="pre">$target_ar</span></code>, etc. to non-empty values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_target_makefile</span></code></dt><dd><p>Write a Makefile fragment to stdout, exposing the result of the most
<code class="docutils literal notranslate"><span class="pre">probe_target_compiler</span></code> call as the usual Make variables (<code class="docutils literal notranslate"><span class="pre">CC</span></code>,
<code class="docutils literal notranslate"><span class="pre">AR</span></code>, <code class="docutils literal notranslate"><span class="pre">LD</span></code>, etc.).</p>
</dd>
</dl>
<p>Configure does not generally perform tests for compiler options beyond
basic checks to detect the host platform and ensure the compiler is
functioning.  These are performed using a few more helper functions:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">compile_object</span> <span class="pre">$CFLAGS</span></code></dt><dd><p>Attempt to compile a test program with the system C compiler using
$CFLAGS. The test program must have been previously written to a file
called $TMPC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compile_prog</span> <span class="pre">$CFLAGS</span> <span class="pre">$LDFLAGS</span></code></dt><dd><p>Attempt to compile a test program with the system C compiler using
$CFLAGS and link it with the system linker using $LDFLAGS. The test
program must have been previously written to a file called $TMPC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">check_define</span> <span class="pre">$NAME</span></code></dt><dd><p>Determine if the macro $NAME is defined by the system C compiler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">do_compiler</span> <span class="pre">$CC</span> <span class="pre">$ARGS...</span></code></dt><dd><p>Attempt to run the C compiler $CC, passing it $ARGS…  This function
does not use flags passed via options such as <code class="docutils literal notranslate"><span class="pre">--extra-cflags</span></code>, and
therefore can be used to check for cross compilers.  However, most
such checks are done at <code class="docutils literal notranslate"><span class="pre">make</span></code> time instead (see for example the
<code class="docutils literal notranslate"><span class="pre">cc-option</span></code> macro in <code class="docutils literal notranslate"><span class="pre">pc-bios/option-rom/Makefile</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_c_skeleton</span></code></dt><dd><p>Write a minimal C program main() function to the temporary file
indicated by $TMPC.</p>
</dd>
</dl>
</section>
<section id="python-virtual-environments-and-the-build-process">
<h3>Python virtual environments and the build process<a class="headerlink" href="#python-virtual-environments-and-the-build-process" title="Permalink to this headline"></a></h3>
<p>An important step in <code class="docutils literal notranslate"><span class="pre">configure</span></code> is to create a Python virtual
environment (venv) during the configuration phase.  The Python interpreter
comes from the <code class="docutils literal notranslate"><span class="pre">--python</span></code> command line option, the <code class="docutils literal notranslate"><span class="pre">$PYTHON</span></code> variable
from the environment, or the system PATH, in this order.  The venv resides
in the <code class="docutils literal notranslate"><span class="pre">pyvenv</span></code> directory in the build tree, and provides consistency
in how the build process runs Python code.</p>
<p>At this stage, <code class="docutils literal notranslate"><span class="pre">configure</span></code> also queries the chosen Python interpreter
about QEMU’s build dependencies.  Note that the build process does  <em>not</em>
look for <code class="docutils literal notranslate"><span class="pre">meson</span></code> or <code class="docutils literal notranslate"><span class="pre">sphinx-build</span></code> binaries in the PATH;
likewise, there are no options such as <code class="docutils literal notranslate"><span class="pre">--meson</span></code> or <code class="docutils literal notranslate"><span class="pre">--sphinx-build</span></code>.
This avoids a potential mismatch, where Meson and Sphinx binaries on the
PATH might operate in a different Python environment than the one chosen
by the user during the build process.  On the other hand, it introduces
a potential source of confusion where the user installs a dependency but
<code class="docutils literal notranslate"><span class="pre">configure</span></code> is not able to find it.  When this happens, the dependency
was installed in the <code class="docutils literal notranslate"><span class="pre">site-packages</span></code> directory of another interpreter,
or with the wrong <code class="docutils literal notranslate"><span class="pre">pip</span></code> program.</p>
<p>If a package is available for the chosen interpreter, <code class="docutils literal notranslate"><span class="pre">configure</span></code>
prepares a small script that invokes it from the venv itself<a class="footnote-reference brackets" href="#distlib" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.
If not, <code class="docutils literal notranslate"><span class="pre">configure</span></code> can also optionally install dependencies in the
virtual environment with <code class="docutils literal notranslate"><span class="pre">pip</span></code>, either from wheels in <code class="docutils literal notranslate"><span class="pre">python/wheels</span></code>
or by downloading the package with PyPI.  Downloading can be disabled with
<code class="docutils literal notranslate"><span class="pre">--disable-download</span></code>; and anyway, it only happens when a <code class="docutils literal notranslate"><span class="pre">configure</span></code>
option (currently, only <code class="docutils literal notranslate"><span class="pre">--enable-docs</span></code>) is explicitly enabled but
the dependencies are not present.</p>
<aside class="footnote brackets" id="distlib" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>The scripts are created based on the package’s metadata,
specifically the <code class="docutils literal notranslate"><span class="pre">console_script</span></code> entry points.  This is the
same mechanism that <code class="docutils literal notranslate"><span class="pre">pip</span></code> uses when installing a package.
Currently, in all cases it would be possible to use <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span></code>
instead of an entry point script, which makes this approach a
bit overkill.  On the other hand, creating the scripts is
future proof and it makes the contents of the <code class="docutils literal notranslate"><span class="pre">pyvenv/bin</span></code>
directory more informative.  Portability is also not an issue,
because the Python Packaging Authority provides a package
<code class="docutils literal notranslate"><span class="pre">distlib.scripts</span></code> to perform this task.</p>
</aside>
<p>The required versions of the packages are stored in a configuration file
<code class="docutils literal notranslate"><span class="pre">pythondeps.toml</span></code>.  The format is custom to QEMU, but it is documented
at the top of the file itself and it should be easy to understand.  The
requirements should make it possible to use the version that is packaged
by QEMU’s supported distros.</p>
<p>When dependencies are downloaded, instead, <code class="docutils literal notranslate"><span class="pre">configure</span></code> uses a “known
good” version that is also listed in <code class="docutils literal notranslate"><span class="pre">pythondeps.toml</span></code>.  In this
scenario, <code class="docutils literal notranslate"><span class="pre">pythondeps.toml</span></code> behaves like the “lock file” used by
<code class="docutils literal notranslate"><span class="pre">cargo</span></code>, <code class="docutils literal notranslate"><span class="pre">poetry</span></code> or other dependency management systems.</p>
</section>
<section id="bundled-python-packages">
<h3>Bundled Python packages<a class="headerlink" href="#bundled-python-packages" title="Permalink to this headline"></a></h3>
<p>Python packages that are <strong>mandatory</strong> dependencies to build QEMU,
but are not available in all supported distros, are bundled with the
QEMU sources.  The only one is currently Meson (outdated in Ubuntu
22.04 and openSUSE Leap).</p>
<p>In order to include a new or updated wheel, modify and rerun the
<code class="docutils literal notranslate"><span class="pre">python/scripts/vendor.py</span></code> script.  The script embeds the
sha256 hash of package sources and checks it.  The pypi.org web site
provides an easy way to retrieve the sha256 hash of the sources.</p>
</section>
</section>
<section id="stage-2-meson">
<h2>Stage 2: Meson<a class="headerlink" href="#stage-2-meson" title="Permalink to this headline"></a></h2>
<p>The Meson build system describes the build and install process for:</p>
<ol class="arabic simple">
<li><p>executables, which include:</p>
<ul class="simple">
<li><p>Tools - <code class="docutils literal notranslate"><span class="pre">qemu-img</span></code>, <code class="docutils literal notranslate"><span class="pre">qemu-nbd</span></code>, <code class="docutils literal notranslate"><span class="pre">qemu-ga</span></code> (guest agent), etc</p></li>
<li><p>System emulators - <code class="docutils literal notranslate"><span class="pre">qemu-system-$ARCH</span></code></p></li>
<li><p>Userspace emulators - <code class="docutils literal notranslate"><span class="pre">qemu-$ARCH</span></code></p></li>
<li><p>Unit tests</p></li>
</ul>
</li>
<li><p>documentation</p></li>
<li><p>ROMs, whether provided as binary blobs in the QEMU distributions
or cross compiled under the direction of the configure script</p></li>
<li><p>other data files, such as icons or desktop files</p></li>
</ol>
<p>All executables are built by default, except for some <code class="docutils literal notranslate"><span class="pre">contrib/</span></code>
binaries that are known to fail to build on some platforms (for example
32-bit or big-endian platforms).  Tests are also built by default,
though that might change in the future.</p>
<p>The source code is highly modularized, split across many files to
facilitate building of all of these components with as little duplicated
compilation as possible. Using the Meson “sourceset” functionality,
<code class="docutils literal notranslate"><span class="pre">meson.build</span></code> files group the source files in rules that are
enabled according to the available system libraries and to various
configuration symbols.  Sourcesets belong to one of four groups:</p>
<dl>
<dt>Subsystem sourcesets:</dt><dd><p>Various subsystems that are common to both tools and emulators have
their own sourceset, for example <code class="docutils literal notranslate"><span class="pre">block_ss</span></code> for the block device subsystem,
<code class="docutils literal notranslate"><span class="pre">chardev_ss</span></code> for the character device subsystem, etc.  These sourcesets
are then turned into static libraries as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">libchardev</span> <span class="o">=</span> <span class="n">static_library</span><span class="p">(</span><span class="s1">&#39;chardev&#39;</span><span class="p">,</span> <span class="n">chardev_ss</span><span class="o">.</span><span class="n">sources</span><span class="p">(),</span>
                            <span class="n">build_by_default</span><span class="p">:</span> <span class="n">false</span><span class="p">)</span>

<span class="n">chardev</span> <span class="o">=</span> <span class="n">declare_dependency</span><span class="p">(</span><span class="n">objects</span><span class="p">:</span> <span class="n">libchardev</span><span class="o">.</span><span class="n">extract_all_objects</span><span class="p">(</span><span class="n">recursive</span><span class="p">:</span> <span class="n">false</span><span class="p">),</span>
                             <span class="n">dependencies</span><span class="p">:</span> <span class="n">chardev_ss</span><span class="o">.</span><span class="n">dependencies</span><span class="p">())</span>
</pre></div>
</div>
</dd>
<dt>Target-independent emulator sourcesets:</dt><dd><p>Various general purpose helper code is compiled only once and
the .o files are linked into all output binaries that need it.
This includes error handling infrastructure, standard data structures,
platform portability wrapper functions, etc.</p>
<p>Target-independent code lives in the <code class="docutils literal notranslate"><span class="pre">common_ss</span></code>, <code class="docutils literal notranslate"><span class="pre">system_ss</span></code> and
<code class="docutils literal notranslate"><span class="pre">user_ss</span></code> sourcesets.  <code class="docutils literal notranslate"><span class="pre">common_ss</span></code> is linked into all emulators,
<code class="docutils literal notranslate"><span class="pre">system_ss</span></code> only in system emulators, <code class="docutils literal notranslate"><span class="pre">user_ss</span></code> only in user-mode
emulators.</p>
</dd>
<dt>Target-dependent emulator sourcesets:</dt><dd><p>In the target-dependent set lives CPU emulation, some device emulation and
much glue code. This sometimes also has to be compiled multiple times,
once for each target being built.  Target-dependent files are included
in the <code class="docutils literal notranslate"><span class="pre">specific_ss</span></code> sourceset.</p>
<p>Each emulator also includes sources for files in the <code class="docutils literal notranslate"><span class="pre">hw/</span></code> and <code class="docutils literal notranslate"><span class="pre">target/</span></code>
subdirectories.  The subdirectory used for each emulator comes
from the target’s definition of <code class="docutils literal notranslate"><span class="pre">TARGET_BASE_ARCH</span></code> or (if missing)
<code class="docutils literal notranslate"><span class="pre">TARGET_ARCH</span></code>, as found in <code class="docutils literal notranslate"><span class="pre">configs/targets/*.mak</span></code>.</p>
<p>Each subdirectory in <code class="docutils literal notranslate"><span class="pre">hw/</span></code> adds one sourceset to the <code class="docutils literal notranslate"><span class="pre">hw_arch</span></code> dictionary,
for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arm_ss</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">source_set</span><span class="p">()</span>
<span class="n">arm_ss</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">files</span><span class="p">(</span><span class="s1">&#39;boot.c&#39;</span><span class="p">),</span> <span class="n">fdt</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">hw_arch</span> <span class="o">+=</span> <span class="p">{</span><span class="s1">&#39;arm&#39;</span><span class="p">:</span> <span class="n">arm_ss</span><span class="p">}</span>
</pre></div>
</div>
<p>The sourceset is only used for system emulators.</p>
<p>Each subdirectory in <code class="docutils literal notranslate"><span class="pre">target/</span></code> instead should add one sourceset to each
of the <code class="docutils literal notranslate"><span class="pre">target_arch</span></code> and <code class="docutils literal notranslate"><span class="pre">target_system_arch</span></code>, which are used respectively
for all emulators and for system emulators only.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arm_ss</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">source_set</span><span class="p">()</span>
<span class="n">arm_system_ss</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">source_set</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">target_arch</span> <span class="o">+=</span> <span class="p">{</span><span class="s1">&#39;arm&#39;</span><span class="p">:</span> <span class="n">arm_ss</span><span class="p">}</span>
<span class="n">target_system_arch</span> <span class="o">+=</span> <span class="p">{</span><span class="s1">&#39;arm&#39;</span><span class="p">:</span> <span class="n">arm_system_ss</span><span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>Module sourcesets:</dt><dd><p>There are two dictionaries for modules: <code class="docutils literal notranslate"><span class="pre">modules</span></code> is used for
target-independent modules and <code class="docutils literal notranslate"><span class="pre">target_modules</span></code> is used for
target-dependent modules.  When modules are disabled the <code class="docutils literal notranslate"><span class="pre">module</span></code>
source sets are added to <code class="docutils literal notranslate"><span class="pre">system_ss</span></code> and the <code class="docutils literal notranslate"><span class="pre">target_modules</span></code>
source sets are added to <code class="docutils literal notranslate"><span class="pre">specific_ss</span></code>.</p>
<p>Both dictionaries are nested.  One dictionary is created per
subdirectory, and these per-subdirectory dictionaries are added to
the toplevel dictionaries.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hw_display_modules</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">qxl_ss</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">source_set</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">hw_display_modules</span> <span class="o">+=</span> <span class="p">{</span> <span class="s1">&#39;qxl&#39;</span><span class="p">:</span> <span class="n">qxl_ss</span> <span class="p">}</span>
<span class="n">modules</span> <span class="o">+=</span> <span class="p">{</span> <span class="s1">&#39;hw-display&#39;</span><span class="p">:</span> <span class="n">hw_display_modules</span> <span class="p">}</span>
</pre></div>
</div>
</dd>
<dt>Utility sourcesets:</dt><dd><p>All binaries link with a static library <code class="docutils literal notranslate"><span class="pre">libqemuutil.a</span></code>.  This library
is built from several sourcesets; most of them however host generated
code, and the only two of general interest are <code class="docutils literal notranslate"><span class="pre">util_ss</span></code> and <code class="docutils literal notranslate"><span class="pre">stub_ss</span></code>.</p>
<p>The separation between these two is purely for documentation purposes.
<code class="docutils literal notranslate"><span class="pre">util_ss</span></code> contains generic utility files.  Even though this code is only
linked in some binaries, sometimes it requires hooks only in some of
these and depend on other functions that are not fully implemented by
all QEMU binaries.  <code class="docutils literal notranslate"><span class="pre">stub_ss</span></code> links dummy stubs that will only be linked
into the binary if the real implementation is not present.  In a way,
the stubs can be thought of as a portable implementation of the weak
symbols concept.</p>
</dd>
</dl>
<p>The following files concur in the definition of which files are linked
into each emulator:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">configs/devices/*.mak</span></code></dt><dd><p>The files under <code class="docutils literal notranslate"><span class="pre">configs/devices/</span></code> control the boards and devices
that are built into each QEMU system emulation targets. They merely contain
a list of config variable definitions such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">include</span> <span class="n">arm</span><span class="o">-</span><span class="n">softmmu</span><span class="o">.</span><span class="n">mak</span>
<span class="n">CONFIG_XLNX_ZYNQMP_ARM</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_XLNX_VERSAL</span><span class="o">=</span><span class="n">y</span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*/Kconfig</span></code></dt><dd><p>These files are processed together with <code class="docutils literal notranslate"><span class="pre">configs/devices/*.mak</span></code> and
describe the dependencies between various features, subsystems and
device models.  They are described in <a class="reference internal" href="kconfig.html#kconfig"><span class="std std-ref">QEMU and Kconfig</span></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">configs/targets/*.mak</span></code></dt><dd><p>These files mostly define symbols that appear in the <code class="docutils literal notranslate"><span class="pre">*-config-target.h</span></code>
file for each emulator<a class="footnote-reference brackets" href="#cfgtarget" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.  However, the <code class="docutils literal notranslate"><span class="pre">TARGET_ARCH</span></code>
and <code class="docutils literal notranslate"><span class="pre">TARGET_BASE_ARCH</span></code> will also be used to select the <code class="docutils literal notranslate"><span class="pre">hw/</span></code> and
<code class="docutils literal notranslate"><span class="pre">target/</span></code> subdirectories that are compiled into each target.</p>
</dd>
</dl>
<aside class="footnote brackets" id="cfgtarget" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>This header is included by <code class="docutils literal notranslate"><span class="pre">qemu/osdep.h</span></code> when
compiling files from the target-specific sourcesets.</p>
</aside>
<p>These files rarely need changing unless you are adding a completely
new target, or enabling new devices or hardware for a particular
system/userspace emulation target</p>
<section id="adding-checks">
<h3>Adding checks<a class="headerlink" href="#adding-checks" title="Permalink to this headline"></a></h3>
<p>Compiler checks can be as simple as the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">config_host_data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;HAVE_BTRFS_H&#39;</span><span class="p">,</span> <span class="n">cc</span><span class="o">.</span><span class="n">has_header</span><span class="p">(</span><span class="s1">&#39;linux/btrfs.h&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>A more complex task such as adding a new dependency usually
comprises the following tasks:</p>
<blockquote>
<div><ul class="simple">
<li><p>Add a Meson build option to meson_options.txt.</p></li>
<li><p>Add code to perform the actual feature check.</p></li>
<li><p>Add code to include the feature status in <code class="docutils literal notranslate"><span class="pre">config-host.h</span></code></p></li>
<li><p>Add code to print out the feature status in the configure summary
upon completion.</p></li>
</ul>
</div></blockquote>
<p>Taking the probe for SDL2_Image as an example, we have the following
in <code class="docutils literal notranslate"><span class="pre">meson_options.txt</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">option</span><span class="p">(</span><span class="s1">&#39;sdl_image&#39;</span><span class="p">,</span> <span class="nb">type</span> <span class="p">:</span> <span class="s1">&#39;feature&#39;</span><span class="p">,</span> <span class="n">value</span> <span class="p">:</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
       <span class="n">description</span><span class="p">:</span> <span class="s1">&#39;SDL Image support for icons&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Unless the option was given a non-<code class="docutils literal notranslate"><span class="pre">auto</span></code> value (on the configure
command line), the detection code must be performed only if the
dependency will be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sdl_image</span> <span class="o">=</span> <span class="n">not_found</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;sdl_image&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span> <span class="ow">or</span> <span class="n">have_system</span>
  <span class="n">sdl_image</span> <span class="o">=</span> <span class="n">dependency</span><span class="p">(</span><span class="s1">&#39;SDL2_image&#39;</span><span class="p">,</span> <span class="n">required</span><span class="p">:</span> <span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;sdl_image&#39;</span><span class="p">),</span>
                         <span class="n">method</span><span class="p">:</span> <span class="s1">&#39;pkg-config&#39;</span><span class="p">)</span>
<span class="n">endif</span>
</pre></div>
</div>
<p>This avoids warnings on static builds of user-mode emulators, for example.
Most of the libraries used by system-mode emulators are not available for
static linking.</p>
<p>The other supporting code is generally simple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create config-host.h (if applicable)</span>
<span class="n">config_host_data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;CONFIG_SDL_IMAGE&#39;</span><span class="p">,</span> <span class="n">sdl_image</span><span class="o">.</span><span class="n">found</span><span class="p">())</span>

<span class="c1"># Summary</span>
<span class="n">summary_info</span> <span class="o">+=</span> <span class="p">{</span><span class="s1">&#39;SDL image support&#39;</span><span class="p">:</span> <span class="n">sdl_image</span><span class="o">.</span><span class="n">found</span><span class="p">()}</span>
</pre></div>
</div>
<p>For the configure script to parse the new option, the
<code class="docutils literal notranslate"><span class="pre">scripts/meson-buildoptions.sh</span></code> file must be up-to-date; <code class="docutils literal notranslate"><span class="pre">make</span>
<span class="pre">update-buildoptions</span></code> (or just <code class="docutils literal notranslate"><span class="pre">make</span></code>) will take care of updating it.</p>
</section>
<section id="support-scripts">
<h3>Support scripts<a class="headerlink" href="#support-scripts" title="Permalink to this headline"></a></h3>
<p>Meson has a special convention for invoking Python scripts: if their
first line is <code class="docutils literal notranslate"><span class="pre">#!</span> <span class="pre">/usr/bin/env</span> <span class="pre">python3</span></code> and the file is <em>not</em> executable,
find_program() arranges to invoke the script under the same Python
interpreter that was used to invoke Meson.  This is the most common
and preferred way to invoke support scripts from Meson build files,
because it automatically uses the value of configure’s –python= option.</p>
<p>In case the script is not written in Python, use a <code class="docutils literal notranslate"><span class="pre">#!</span> <span class="pre">/usr/bin/env</span> <span class="pre">...</span></code>
line and make the script executable.</p>
<p>Scripts written in Python, where it is desirable to make the script
executable (for example for test scripts that developers may want to
invoke from the command line, such as tests/qapi-schema/test-qapi.py),
should be invoked through the <code class="docutils literal notranslate"><span class="pre">python</span></code> variable in meson.build. For
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">(</span><span class="s1">&#39;QAPI schema regression tests&#39;</span><span class="p">,</span> <span class="n">python</span><span class="p">,</span>
     <span class="n">args</span><span class="p">:</span> <span class="n">files</span><span class="p">(</span><span class="s1">&#39;test-qapi.py&#39;</span><span class="p">),</span>
     <span class="n">env</span><span class="p">:</span> <span class="n">test_env</span><span class="p">,</span> <span class="n">suite</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;qapi-schema&#39;</span><span class="p">,</span> <span class="s1">&#39;qapi-frontend&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>This is needed to obey the –python= option passed to the configure
script, which may point to something other than the first python3
binary on the path.</p>
<p>By the time Meson runs, Python dependencies are available in the virtual
environment and should be invoked through the scripts that <code class="docutils literal notranslate"><span class="pre">configure</span></code>
places under <code class="docutils literal notranslate"><span class="pre">pyvenv</span></code>.  One way to do so is as follows, using Meson’s
<code class="docutils literal notranslate"><span class="pre">find_program</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sphinx_build</span> <span class="o">=</span> <span class="n">find_program</span><span class="p">(</span>
     <span class="n">fs</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">python</span><span class="o">.</span><span class="n">full_path</span><span class="p">())</span> <span class="o">/</span> <span class="s1">&#39;sphinx-build&#39;</span><span class="p">,</span>
     <span class="n">required</span><span class="p">:</span> <span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;docs&#39;</span><span class="p">))</span>
</pre></div>
</div>
</section>
</section>
<section id="stage-3-make">
<h2>Stage 3: Make<a class="headerlink" href="#stage-3-make" title="Permalink to this headline"></a></h2>
<p>The next step in building QEMU is to invoke make.  GNU Make is required
to build QEMU, and may be installed as <code class="docutils literal notranslate"><span class="pre">gmake</span></code> on some hosts.</p>
<p>The output of Meson is a <code class="docutils literal notranslate"><span class="pre">build.ninja</span></code> file, which is used with the
Ninja build tool.  However, QEMU’s build comprises other components than
just the emulators (namely firmware and the tests in <code class="docutils literal notranslate"><span class="pre">tests/tcg</span></code>) which
need different cross compilers.  The QEMU Makefile wraps both Ninja and
the smaller build systems for firmware and tests; it also takes care of
running <code class="docutils literal notranslate"><span class="pre">configure</span></code> again when the script changes.  Apart from invoking
these sub-Makefiles, the resulting build is largely non-recursive.</p>
<p>Tests, whether defined in <code class="docutils literal notranslate"><span class="pre">meson.build</span></code> or not, are also ran by the
Makefile with the traditional <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check</span></code> phony target, while benchmarks
are run with <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">bench</span></code>.  Meson test suites such as <code class="docutils literal notranslate"><span class="pre">unit</span></code> can be ran
with <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check-unit</span></code>, and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check-tcg</span></code> builds and runs “non-Meson”
tests for all targets.</p>
<p>If desired, it is also possible to use <code class="docutils literal notranslate"><span class="pre">ninja</span></code> and <code class="docutils literal notranslate"><span class="pre">meson</span> <span class="pre">test</span></code>,
respectively to build emulators and run tests defined in meson.build.
The main difference is that <code class="docutils literal notranslate"><span class="pre">make</span></code> needs the <code class="docutils literal notranslate"><span class="pre">-jN</span></code> flag in order to
enable parallel builds or tests.</p>
<section id="useful-make-targets">
<h3>Useful make targets<a class="headerlink" href="#useful-make-targets" title="Permalink to this headline"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">help</span></code></dt><dd><p>Print a help message for the most common build targets.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">print-VAR</span></code></dt><dd><p>Print the value of the variable VAR. Useful for debugging the build
system.</p>
</dd>
</dl>
</section>
</section>
<section id="important-files-for-the-build-system">
<h2>Important files for the build system<a class="headerlink" href="#important-files-for-the-build-system" title="Permalink to this headline"></a></h2>
<section id="statically-defined-files">
<h3>Statically defined files<a class="headerlink" href="#statically-defined-files" title="Permalink to this headline"></a></h3>
<p>The following key files are statically defined in the source tree, with
the rules needed to build QEMU. Their behaviour is influenced by a
number of dynamically created files listed later.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Makefile</span></code></dt><dd><p>The main entry point used when invoking make to build all the components
of QEMU. The default ‘all’ target will naturally result in the build of
every component.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*/meson.build</span></code></dt><dd><p>The meson.build file in the root directory is the main entry point for the
Meson build system, and it coordinates the configuration and build of all
executables.  Build rules for various subdirectories are included in
other meson.build files spread throughout the QEMU source tree.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">python/scripts/mkvenv.py</span></code></dt><dd><p>A wrapper for the Python <code class="docutils literal notranslate"><span class="pre">venv</span></code> and <code class="docutils literal notranslate"><span class="pre">distlib.scripts</span></code> packages.
It handles creating the virtual environment, creating scripts in
<code class="docutils literal notranslate"><span class="pre">pyvenv/bin</span></code>, and calling <code class="docutils literal notranslate"><span class="pre">pip</span></code> to install dependencies.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tests/Makefile.include</span></code></dt><dd><p>Rules for external test harnesses like the TCG tests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tests/docker/Makefile.include</span></code></dt><dd><p>Rules for Docker tests. Like <code class="docutils literal notranslate"><span class="pre">tests/Makefile.include</span></code>, this file is
included directly by the top level Makefile, anything defined in this
file will influence the entire build system.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tests/vm/Makefile.include</span></code></dt><dd><p>Rules for VM-based tests. Like <code class="docutils literal notranslate"><span class="pre">tests/Makefile.include</span></code>, this file is
included directly by the top level Makefile, anything defined in this
file will influence the entire build system.</p>
</dd>
</dl>
</section>
<section id="dynamically-created-files">
<h3>Dynamically created files<a class="headerlink" href="#dynamically-created-files" title="Permalink to this headline"></a></h3>
<p>The following files are generated at run-time in order to control the
behaviour of the Makefiles. This avoids the need for QEMU makefiles to
go through any pre-processing as seen with autotools, where configure
generates <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> from <code class="docutils literal notranslate"><span class="pre">Makefile.in</span></code>.</p>
<p>Built by configure:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">config-host.mak</span></code></dt><dd><p>When configure has determined the characteristics of the build host it
will write the paths to various tools to this file, for use in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>
and to a smaller extent <code class="docutils literal notranslate"><span class="pre">meson.build</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">config-host.mak</span></code> is also used as a dependency checking mechanism. If make
sees that the modification timestamp on configure is newer than that on
<code class="docutils literal notranslate"><span class="pre">config-host.mak</span></code>, then configure will be re-run.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">config-meson.cross</span></code></p>
<blockquote>
<div><p>A Meson “cross file” (or native file) used to communicate the paths to
the toolchain and other configuration options.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">config.status</span></code></p>
<blockquote>
<div><p>A small shell script that will invoke configure again with the same
environment variables that were set during the first run.  It’s used to
rerun configure after changes to the source code, but it can also be
inspected manually to check the contents of the environment.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Makefile.prereqs</span></code></p>
<blockquote>
<div><p>A set of Makefile dependencies that order the build and execution of
firmware and tests after the container images and emulators that they
need.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">pc-bios/*/config.mak</span></code>, <code class="docutils literal notranslate"><span class="pre">tests/tcg/config-host.mak</span></code>, <code class="docutils literal notranslate"><span class="pre">tests/tcg/*/config-target.mak</span></code></p>
<blockquote>
<div><p>Configuration variables used to build the firmware and TCG tests,
including paths to cross compilation toolchains.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">pyvenv</span></code></p>
<blockquote>
<div><p>A Python virtual environment that is used for all Python code running
during the build.  Using a virtual environment ensures that even code
that is run via <code class="docutils literal notranslate"><span class="pre">sphinx-build</span></code>, <code class="docutils literal notranslate"><span class="pre">meson</span></code> etc. uses the same interpreter
and packages.</p>
</div></blockquote>
<p>Built by Meson:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">config-host.h</span></code></dt><dd><p>Used by C code to determine the properties of the build environment
and the set of enabled features for the entire build.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">${TARGET-NAME}-config-devices.mak</span></code></dt><dd><p>TARGET-NAME is the name of a system emulator. The file is
generated by Meson using files under <code class="docutils literal notranslate"><span class="pre">configs/devices</span></code> as input.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">${TARGET-NAME}-config-target.mak</span></code></dt><dd><p>TARGET-NAME is the name of a system or usermode emulator. The file is
generated by Meson using files under <code class="docutils literal notranslate"><span class="pre">configs/targets</span></code> as input.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$TARGET_NAME-config-target.h</span></code>, <code class="docutils literal notranslate"><span class="pre">$TARGET_NAME-config-devices.h</span></code></dt><dd><p>Used by C code to determine the properties and enabled
features for each target.  enabled.  They are generated from
the contents of the corresponding <code class="docutils literal notranslate"><span class="pre">*.mak</span></code> files using Meson’s
<code class="docutils literal notranslate"><span class="pre">configure_file()</span></code> function; each target can include them using
the <code class="docutils literal notranslate"><span class="pre">CONFIG_TARGET</span></code> and <code class="docutils literal notranslate"><span class="pre">CONFIG_DEVICES</span></code> macro respectively.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">build.ninja</span></code></dt><dd><p>The build rules.</p>
</dd>
</dl>
<p>Built by Makefile:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Makefile.ninja</span></code></dt><dd><p>A Makefile include that bridges to ninja for the actual build.  The
Makefile is mostly a list of targets that Meson included in build.ninja.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Makefile.mtest</span></code></dt><dd><p>The Makefile definitions that let “make check” run tests defined in
meson.build.  The rules are produced from Meson’s JSON description of
tests (obtained with “meson introspect –tests”) through the script
scripts/mtest2make.py.</p>
</dd>
</dl>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index-build.html" class="btn btn-neutral float-left" title="QEMU Build System" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="build-environment.html" class="btn btn-neutral float-right" title="Setup build environment" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, The QEMU Project Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  

<!-- Empty para to force a blank line after "Built with Sphinx ..." -->
<p></p>

<p>This documentation is for QEMU version 10.0.50.</p>


<p><a href="../about/license.html">QEMU and this manual are released under the
GNU General Public License, version 2.</a></p>

 


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>