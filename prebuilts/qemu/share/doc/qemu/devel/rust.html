<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rust in QEMU &mdash; QEMU  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/qemu_32x32.png"/>
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/custom.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="QEMU Build System" href="index-build.html" />
    <link rel="prev" title="Secure Coding Practices" href="secure-coding-practices.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #802400" >
            <a href="../index.html" class="icon icon-home"> QEMU
            <img src="../_static/qemu_128x128.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                10.0.50
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">About QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/index.html">System Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User Mode Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interop/index.html">System Emulation Management and Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../specs/index.html">System Emulation Guest Hardware Specifications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Information</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index-process.html">QEMU Community Processes</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="code-of-conduct.html">Code of Conduct</a></li>
<li class="toctree-l3"><a class="reference internal" href="conflict-resolution.html">Conflict Resolution Policy</a></li>
<li class="toctree-l3"><a class="reference internal" href="maintainers.html">The Role of Maintainers</a></li>
<li class="toctree-l3"><a class="reference internal" href="style.html">QEMU Coding Style</a></li>
<li class="toctree-l3"><a class="reference internal" href="submitting-a-patch.html">Submitting a Patch</a></li>
<li class="toctree-l3"><a class="reference internal" href="trivial-patches.html">Trivial Patches</a></li>
<li class="toctree-l3"><a class="reference internal" href="stable-process.html">QEMU and the stable process</a></li>
<li class="toctree-l3"><a class="reference internal" href="submitting-a-pull-request.html">Submitting a Pull Request</a></li>
<li class="toctree-l3"><a class="reference internal" href="secure-coding-practices.html">Secure Coding Practices</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Rust in QEMU</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#building-the-rust-in-qemu-code">Building the Rust in QEMU code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-rust-code-in-qemu">Writing Rust code in QEMU</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adding-dependencies">Adding dependencies</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index-build.html">QEMU Build System</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing/index.html">Testing QEMU</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-api.html">Internal QEMU APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-internals.html">Internal Subsystem Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-tcg.html">TCG Emulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="codebase.html">Codebase</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #802400" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QEMU</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Developer Information</a> &raquo;</li>
          <li><a href="index-process.html">QEMU Community Processes</a> &raquo;</li>
      <li>Rust in QEMU</li>
      <li class="wy-breadcrumbs-aside">
            <a href="https://gitlab.com/qemu-project/qemu/-/blob/master/docs/devel/rust.rst">View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="rust-in-qemu">
<h1>Rust in QEMU<a class="headerlink" href="#rust-in-qemu" title="Permalink to this headline"></a></h1>
<p>Rust in QEMU is a project to enable using the Rust programming language
to add new functionality to QEMU.</p>
<p>Right now, the focus is on making it possible to write devices that inherit
from <code class="docutils literal notranslate"><span class="pre">SysBusDevice</span></code> in <a class="reference external" href="https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html">*safe*</a> Rust.  Later, it may become possible
to write other kinds of devices (e.g. PCI devices that can do DMA),
complete boards, or backends (e.g. block device formats).</p>
<section id="building-the-rust-in-qemu-code">
<h2>Building the Rust in QEMU code<a class="headerlink" href="#building-the-rust-in-qemu-code" title="Permalink to this headline"></a></h2>
<p>The Rust in QEMU code is included in the emulators via Meson.  Meson
invokes rustc directly, building static libraries that are then linked
together with the C code.  This is completely automatic when you run
<code class="docutils literal notranslate"><span class="pre">make</span></code> or <code class="docutils literal notranslate"><span class="pre">ninja</span></code>.</p>
<p>However, QEMU’s build system also tries to be easy to use for people who
are accustomed to the more “normal” Cargo-based development workflow.
In particular:</p>
<ul class="simple">
<li><p>the set of warnings and lints that are used to build QEMU always
comes from the <code class="docutils literal notranslate"><span class="pre">rust/Cargo.toml</span></code> workspace file</p></li>
<li><p>it is also possible to use <code class="docutils literal notranslate"><span class="pre">cargo</span></code> for common Rust-specific coding
tasks, in particular to invoke <code class="docutils literal notranslate"><span class="pre">clippy</span></code>, <code class="docutils literal notranslate"><span class="pre">rustfmt</span></code> and <code class="docutils literal notranslate"><span class="pre">rustdoc</span></code>.</p></li>
</ul>
<p>To this end, QEMU includes a <code class="docutils literal notranslate"><span class="pre">build.rs</span></code> build script that picks up
generated sources from QEMU’s build directory and puts it in Cargo’s
output directory (typically <code class="docutils literal notranslate"><span class="pre">rust/target/</span></code>).  A vanilla invocation
of Cargo will complain that it cannot find the generated sources,
which can be fixed in different ways:</p>
<ul>
<li><p>by using special shorthand targets in the QEMU build directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">clippy</span>
<span class="n">make</span> <span class="n">rustfmt</span>
<span class="n">make</span> <span class="n">rustdoc</span>
</pre></div>
</div>
</li>
<li><p>by invoking <code class="docutils literal notranslate"><span class="pre">cargo</span></code> through the Meson <a class="reference external" href="https://mesonbuild.com/Commands.html#devenv">development environment</a>
feature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyvenv</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">meson</span> <span class="n">devenv</span> <span class="o">-</span><span class="n">w</span> <span class="o">../</span><span class="n">rust</span> <span class="n">cargo</span> <span class="n">clippy</span> <span class="o">--</span><span class="n">tests</span>
<span class="n">pyvenv</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">meson</span> <span class="n">devenv</span> <span class="o">-</span><span class="n">w</span> <span class="o">../</span><span class="n">rust</span> <span class="n">cargo</span> <span class="n">fmt</span>
</pre></div>
</div>
<p>If you are going to use <code class="docutils literal notranslate"><span class="pre">cargo</span></code> repeatedly, <code class="docutils literal notranslate"><span class="pre">pyvenv/bin/meson</span> <span class="pre">devenv</span></code>
will enter a shell where commands like <code class="docutils literal notranslate"><span class="pre">cargo</span> <span class="pre">clippy</span></code> just work.</p>
</li>
</ul>
<ul class="simple">
<li><p>by pointing the <code class="docutils literal notranslate"><span class="pre">MESON_BUILD_ROOT</span></code> to the top of your QEMU build
tree.  This third method is useful if you are using <code class="docutils literal notranslate"><span class="pre">rust-analyzer</span></code>;
you can set the environment variable through the
<code class="docutils literal notranslate"><span class="pre">rust-analyzer.cargo.extraEnv</span></code> setting.</p></li>
</ul>
<p>As shown above, you can use the <code class="docutils literal notranslate"><span class="pre">--tests</span></code> option as usual to operate on test
code.  Note however that you cannot <em>build</em> or run tests via <code class="docutils literal notranslate"><span class="pre">cargo</span></code>, because
they need support C code from QEMU that Cargo does not know about.  Tests can
be run via <code class="docutils literal notranslate"><span class="pre">meson</span> <span class="pre">test</span></code> or <code class="docutils literal notranslate"><span class="pre">make</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">check</span><span class="o">-</span><span class="n">rust</span>
</pre></div>
</div>
<p>Building Rust code with <code class="docutils literal notranslate"><span class="pre">--enable-modules</span></code> is not supported yet.</p>
<section id="supported-tools">
<h3>Supported tools<a class="headerlink" href="#supported-tools" title="Permalink to this headline"></a></h3>
<p>QEMU supports rustc version 1.77.0 and newer.  Notably, the following features
are missing:</p>
<ul class="simple">
<li><p>inline const expression (stable in 1.79.0), currently worked around with
associated constants in the <code class="docutils literal notranslate"><span class="pre">FnCall</span></code> trait.</p></li>
<li><p>associated constants have to be explicitly marked <code class="docutils literal notranslate"><span class="pre">'static</span></code> (<a class="reference external" href="https://github.com/rust-lang/rust/pull/125258">changed in
1.81.0</a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;raw</span></code> (stable in 1.82.0).  Use <code class="docutils literal notranslate"><span class="pre">addr_of!</span></code> and <code class="docutils literal notranslate"><span class="pre">addr_of_mut!</span></code> instead,
though hopefully the need for raw pointers will go down over time.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new_uninit</span></code> (stable in 1.82.0).  This is used internally by the <code class="docutils literal notranslate"><span class="pre">pinned_init</span></code>
crate, which is planned for inclusion in QEMU, but it can be easily patched
out.</p></li>
<li><p>referencing statics in constants (stable in 1.83.0).  For now use a const
function; this is an important limitation for QEMU’s migration stream
architecture (VMState).  Right now, VMState lacks type safety because
it is hard to place the <code class="docutils literal notranslate"><span class="pre">VMStateField</span></code> definitions in traits.</p></li>
<li><p>associated const equality would be nice to have for some users of
<code class="docutils literal notranslate"><span class="pre">callbacks::FnCall</span></code>, but is still experimental.  <code class="docutils literal notranslate"><span class="pre">ASSERT_IS_SOME</span></code>
replaces it.</p></li>
</ul>
<p>QEMU also supports version 0.60.x of bindgen, which is missing option
<code class="docutils literal notranslate"><span class="pre">--generate-cstr</span></code>.  This option requires version 0.66.x and will
be adopted as soon as supporting these older versions is not necessary
anymore.</p>
</section>
</section>
<section id="writing-rust-code-in-qemu">
<h2>Writing Rust code in QEMU<a class="headerlink" href="#writing-rust-code-in-qemu" title="Permalink to this headline"></a></h2>
<p>QEMU includes four crates:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">qemu_api</span></code> for bindings to C code and useful functionality</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qemu_api_macros</span></code> defines several procedural macros that are useful when
writing C code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pl011</span></code> (under <code class="docutils literal notranslate"><span class="pre">rust/hw/char/pl011</span></code>) and <code class="docutils literal notranslate"><span class="pre">hpet</span></code> (under <code class="docutils literal notranslate"><span class="pre">rust/hw/timer/hpet</span></code>)
are sample devices that demonstrate <code class="docutils literal notranslate"><span class="pre">qemu_api</span></code> and <code class="docutils literal notranslate"><span class="pre">qemu_api_macros</span></code>, and are
used to further develop them.  These two crates are functional<a class="footnote-reference brackets" href="#issues" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> replacements
for the <code class="docutils literal notranslate"><span class="pre">hw/char/pl011.c</span></code> and <code class="docutils literal notranslate"><span class="pre">hw/timer/hpet.c</span></code> files.</p></li>
</ul>
<aside class="footnote brackets" id="issues" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">1</a><span class="fn-bracket">]</span></span>
<p>The <code class="docutils literal notranslate"><span class="pre">pl011</span></code> crate is synchronized with <code class="docutils literal notranslate"><span class="pre">hw/char/pl011.c</span></code>
as of commit 3e0f118f82.  The <code class="docutils literal notranslate"><span class="pre">hpet</span></code> crate is synchronized as of
commit 1433e38cc8.  Both are lacking tracing functionality.</p>
</aside>
<p>This section explains how to work with them.</p>
<section id="status">
<h3>Status<a class="headerlink" href="#status" title="Permalink to this headline"></a></h3>
<p>Modules of <code class="docutils literal notranslate"><span class="pre">qemu_api</span></code> can be defined as:</p>
<ul class="simple">
<li><p><em>complete</em>: ready for use in new devices; if applicable, the API supports the
full functionality available in C</p></li>
<li><p><em>stable</em>: ready for production use, the API is safe and should not undergo
major changes</p></li>
<li><p><em>proof of concept</em>: the API is subject to change but allows working with safe
Rust</p></li>
<li><p><em>initial</em>: the API is in its initial stages; it requires large amount of
unsafe code; it might have soundness or type-safety issues</p></li>
</ul>
<p>The status of the modules is as follows:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>module</p></th>
<th class="head"><p>status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">assertions</span></code></p></td>
<td><p>stable</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">bitops</span></code></p></td>
<td><p>complete</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">callbacks</span></code></p></td>
<td><p>complete</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cell</span></code></p></td>
<td><p>stable</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">errno</span></code></p></td>
<td><p>complete</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">irq</span></code></p></td>
<td><p>complete</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">memory</span></code></p></td>
<td><p>stable</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">module</span></code></p></td>
<td><p>complete</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">offset_of</span></code></p></td>
<td><p>stable</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">qdev</span></code></p></td>
<td><p>stable</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">qom</span></code></p></td>
<td><p>stable</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sysbus</span></code></p></td>
<td><p>stable</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">timer</span></code></p></td>
<td><p>stable</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">vmstate</span></code></p></td>
<td><p>proof of concept</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">zeroable</span></code></p></td>
<td><p>stable</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>API stability is not a promise, if anything because the C APIs are not a stable
interface either.  Also, <code class="docutils literal notranslate"><span class="pre">unsafe</span></code> interfaces may be replaced by safe interfaces
later.</p>
</aside>
</section>
<section id="naming-convention">
<h3>Naming convention<a class="headerlink" href="#naming-convention" title="Permalink to this headline"></a></h3>
<p>C function names usually are prefixed according to the data type that they
apply to, for example <code class="docutils literal notranslate"><span class="pre">timer_mod</span></code> or <code class="docutils literal notranslate"><span class="pre">sysbus_connect_irq</span></code>.  Furthermore,
both function and structs sometimes have a <code class="docutils literal notranslate"><span class="pre">qemu_</span></code> or <code class="docutils literal notranslate"><span class="pre">QEMU</span></code> prefix.
Generally speaking, these are all removed in the corresponding Rust functions:
<code class="docutils literal notranslate"><span class="pre">QEMUTimer</span></code> becomes <code class="docutils literal notranslate"><span class="pre">timer::Timer</span></code>, <code class="docutils literal notranslate"><span class="pre">timer_mod</span></code> becomes <code class="docutils literal notranslate"><span class="pre">Timer::modify</span></code>,
<code class="docutils literal notranslate"><span class="pre">sysbus_connect_irq</span></code> becomes <code class="docutils literal notranslate"><span class="pre">SysBusDeviceMethods::connect_irq</span></code>.</p>
<p>Sometimes however a name appears multiple times in the QOM class hierarchy,
and the only difference is in the prefix.  An example is <code class="docutils literal notranslate"><span class="pre">qdev_realize</span></code> and
<code class="docutils literal notranslate"><span class="pre">sysbus_realize</span></code>.  In such cases, whenever a name is not unique in
the hierarchy, always add the prefix to the classes that are lower in
the hierarchy; for the top class, decide on a case by case basis.</p>
<p>For example:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">device_cold_reset()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">DeviceMethods::cold_reset()</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pci_device_reset()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PciDeviceMethods::pci_device_reset()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pci_bridge_reset()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PciBridgeMethods::pci_bridge_reset()</span></code></p></td>
</tr>
</tbody>
</table>
<p>Here, the name is not exactly the same, but nevertheless <code class="docutils literal notranslate"><span class="pre">PciDeviceMethods</span></code>
adds the prefix to avoid confusion, because the functionality of
<code class="docutils literal notranslate"><span class="pre">device_cold_reset()</span></code> and <code class="docutils literal notranslate"><span class="pre">pci_device_reset()</span></code> is subtly different.</p>
<p>In this case, however, no prefix is needed:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">device_realize()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">DeviceMethods::realize()</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sysbus_realize()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SysbusDeviceMethods::sysbus_realize()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pci_realize()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PciDeviceMethods::pci_realize()</span></code></p></td>
</tr>
</tbody>
</table>
<p>Here, the lower classes do not add any functionality, and mostly
provide extra compile-time checking; the basic <em>realize</em> functionality
is the same for all devices.  Therefore, <code class="docutils literal notranslate"><span class="pre">DeviceMethods</span></code> does not
add the prefix.</p>
<p>Whenever a name is unique in the hierarchy, instead, you should
always remove the class name prefix.</p>
</section>
<section id="common-pitfalls">
<h3>Common pitfalls<a class="headerlink" href="#common-pitfalls" title="Permalink to this headline"></a></h3>
<p>Rust has very strict rules with respect to how you get an exclusive (<code class="docutils literal notranslate"><span class="pre">&amp;mut</span></code>)
reference; failure to respect those rules is a source of undefined behavior.
In particular, even if a value is loaded from a raw mutable pointer (<code class="docutils literal notranslate"><span class="pre">*mut</span></code>),
it <em>cannot</em> be casted to <code class="docutils literal notranslate"><span class="pre">&amp;mut</span></code> unless the value was stored to the <code class="docutils literal notranslate"><span class="pre">*mut</span></code>
from a mutable reference.  Furthermore, it is undefined behavior if any
shared reference was created between the store to the <code class="docutils literal notranslate"><span class="pre">*mut</span></code> and the load:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let mut p: u32 = 42;
let p_mut = &amp;mut p;                              // 1
let p_raw = p_mut as *mut u32;                   // 2

// p_raw keeps the mutable reference &quot;alive&quot;

let p_shared = &amp;p;                               // 3
println!(&quot;access from &amp;u32: {}&quot;, *p_shared);

// Bring back the mutable reference, its lifetime overlaps
// with that of a shared reference.
let p_mut = unsafe { &amp;mut *p_raw };              // 4
println!(&quot;access from &amp;mut 32: {}&quot;, *p_mut);

println!(&quot;access from &amp;u32: {}&quot;, *p_shared);     // 5
</pre></div>
</div>
<p>These rules can be tested with <a class="reference external" href="https://github.com/rust-lang/miri">MIRI</a>, for example.</p>
<p>Almost all Rust code in QEMU will involve QOM objects, and pointers to these
objects are <em>shared</em>, for example because they are part of the QOM composition
tree.  This creates exactly the above scenario:</p>
<ol class="arabic simple">
<li><p>a QOM object is created</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">*mut</span></code> is created, for example as the opaque value for a <code class="docutils literal notranslate"><span class="pre">MemoryRegion</span></code></p></li>
<li><p>the QOM object is placed in the composition tree</p></li>
<li><p>a memory access dereferences the opaque value to a <code class="docutils literal notranslate"><span class="pre">&amp;mut</span></code></p></li>
<li><p>but the shared reference is still present in the composition tree</p></li>
</ol>
<p>Because of this, QOM objects should almost always use <code class="docutils literal notranslate"><span class="pre">&amp;self</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">self</span></code>; access to internal fields must use <em>interior mutability</em>
to go from a shared reference to a <code class="docutils literal notranslate"><span class="pre">&amp;mut</span></code>.</p>
<p>Whenever C code provides you with an opaque <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>, avoid converting it
to a Rust mutable reference, and use a shared reference instead.  The
<code class="docutils literal notranslate"><span class="pre">qemu_api::cell</span></code> module provides wrappers that can be used to tell the
Rust compiler about interior mutability, and optionally to enforce locking
rules for the “Big QEMU Lock”.  In the future, similar cell types might
also be provided for <code class="docutils literal notranslate"><span class="pre">AioContext</span></code>-based locking as well.</p>
<p>In particular, device code will usually rely on the <code class="docutils literal notranslate"><span class="pre">BqlRefCell</span></code> and
<code class="docutils literal notranslate"><span class="pre">BqlCell</span></code> type to ensure that data is accessed correctly under the
“Big QEMU Lock”.  These cell types are also known to the <code class="docutils literal notranslate"><span class="pre">vmstate</span></code>
crate, which is able to “look inside” them when building an in-memory
representation of a <code class="docutils literal notranslate"><span class="pre">struct</span></code>’s layout.  Note that the same is not true
of a <code class="docutils literal notranslate"><span class="pre">RefCell</span></code> or <code class="docutils literal notranslate"><span class="pre">Mutex</span></code>.</p>
<p>Bindings code instead will usually use the <code class="docutils literal notranslate"><span class="pre">Opaque</span></code> type, which hides
the contents of the underlying struct and can be easily converted to
a raw pointer, for use in calls to C functions.  It can be used for
example as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#[repr(transparent)]</span>
<span class="c1">#[derive(Debug, qemu_api_macros::Wrapper)]</span>
<span class="n">pub</span> <span class="n">struct</span> <span class="n">Object</span><span class="p">(</span><span class="n">Opaque</span><span class="o">&lt;</span><span class="n">bindings</span><span class="p">::</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>where the special <code class="docutils literal notranslate"><span class="pre">derive</span></code> macro provides useful methods such as
<code class="docutils literal notranslate"><span class="pre">from_raw</span></code>, <code class="docutils literal notranslate"><span class="pre">as_ptr`,</span> <span class="pre">``as_mut_ptr</span></code> and <code class="docutils literal notranslate"><span class="pre">raw_get</span></code>.  The bindings will
then manually check for the big QEMU lock with assertions, which allows
the wrapper to be declared thread-safe:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsafe</span> <span class="n">impl</span> <span class="n">Send</span> <span class="k">for</span> <span class="n">Object</span> <span class="p">{}</span>
<span class="n">unsafe</span> <span class="n">impl</span> <span class="n">Sync</span> <span class="k">for</span> <span class="n">Object</span> <span class="p">{}</span>
</pre></div>
</div>
</section>
<section id="writing-bindings-to-c-code">
<h3>Writing bindings to C code<a class="headerlink" href="#writing-bindings-to-c-code" title="Permalink to this headline"></a></h3>
<p>Here are some things to keep in mind when working on the <code class="docutils literal notranslate"><span class="pre">qemu_api</span></code> crate.</p>
<dl class="simple">
<dt><strong>Look at existing code</strong></dt><dd><p>Very often, similar idioms in C code correspond to similar tricks in
Rust bindings.  If the C code uses <code class="docutils literal notranslate"><span class="pre">offsetof</span></code>, look at qdev properties
or <code class="docutils literal notranslate"><span class="pre">vmstate</span></code>.  If the C code has a complex const struct, look at
<code class="docutils literal notranslate"><span class="pre">MemoryRegion</span></code>.  Reuse existing patterns for handling lifetimes;
for example use <code class="docutils literal notranslate"><span class="pre">&amp;T</span></code> for QOM objects that do not need a reference
count (including those that can be embedded in other objects) and
<code class="docutils literal notranslate"><span class="pre">Owned&lt;T&gt;</span></code> for those that need it.</p>
</dd>
<dt><strong>Use the type system</strong></dt><dd><p>Bindings often will need access information that is specific to a type
(either a builtin one or a user-defined one) in order to pass it to C
functions.  Put them in a trait and access it through generic parameters.
The <code class="docutils literal notranslate"><span class="pre">vmstate</span></code> module has examples of how to retrieve type information
for the fields of a Rust <code class="docutils literal notranslate"><span class="pre">struct</span></code>.</p>
</dd>
<dt><strong>Prefer unsafe traits to unsafe functions</strong></dt><dd><p>Unsafe traits are much easier to prove correct than unsafe functions.
They are an excellent place to store metadata that can later be accessed
by generic functions.  C code usually places metadata in global variables;
in Rust, they can be stored in traits and then turned into <code class="docutils literal notranslate"><span class="pre">static</span></code>
variables.  Often, unsafe traits can be generated by procedural macros.</p>
</dd>
<dt><strong>Document limitations due to old Rust versions</strong></dt><dd><p>If you need to settle for an inferior solution because of the currently
supported set of Rust versions, document it in the source and in this
file.  This ensures that it can be fixed when the minimum supported
version is bumped.</p>
</dd>
<dt><strong>Keep locking in mind</strong>.</dt><dd><p>When marking a type <code class="docutils literal notranslate"><span class="pre">Sync</span></code>, be careful of whether it needs the big
QEMU lock.  Use <code class="docutils literal notranslate"><span class="pre">BqlCell</span></code> and <code class="docutils literal notranslate"><span class="pre">BqlRefCell</span></code> for interior data,
or assert <code class="docutils literal notranslate"><span class="pre">bql_locked()</span></code>.</p>
</dd>
<dt><strong>Don’t be afraid of complexity, but document and isolate it</strong></dt><dd><p>It’s okay to be tricky; device code is written more often than bindings
code and it’s important that it is idiomatic.  However, you should strive
to isolate any tricks in a place (for example a <code class="docutils literal notranslate"><span class="pre">struct</span></code>, a trait
or a macro) where it can be documented and tested.  If needed, include
toy versions of the code in the documentation.</p>
</dd>
</dl>
</section>
<section id="writing-procedural-macros">
<h3>Writing procedural macros<a class="headerlink" href="#writing-procedural-macros" title="Permalink to this headline"></a></h3>
<p>By conventions, procedural macros are split in two functions, one
returning <code class="docutils literal notranslate"><span class="pre">Result&lt;proc_macro2::TokenStream,</span> <span class="pre">MacroError&gt;</span></code> with the body of
the procedural macro, and the second returning <code class="docutils literal notranslate"><span class="pre">proc_macro::TokenStream</span></code>
which is the actual procedural macro.  The former’s name is the same as
the latter with the <code class="docutils literal notranslate"><span class="pre">_or_error</span></code> suffix.  The code for the latter is more
or less fixed; it follows the following template, which is fixed apart
from the type after <code class="docutils literal notranslate"><span class="pre">as</span></code> in the invocation of <code class="docutils literal notranslate"><span class="pre">parse_macro_input!</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#[proc_macro_derive(Object)]
pub fn derive_object(input: TokenStream) -&gt; TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let expanded = derive_object_or_error(input).unwrap_or_else(Into::into);

    TokenStream::from(expanded)
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">qemu_api_macros</span></code> crate has utility functions to examine a
<code class="docutils literal notranslate"><span class="pre">DeriveInput</span></code> and perform common checks (e.g. looking for a struct
with named fields).  These functions return <code class="docutils literal notranslate"><span class="pre">Result&lt;...,</span> <span class="pre">MacroError&gt;</span></code>
and can be used easily in the procedural macro function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fn derive_object_or_error(input: DeriveInput) -&gt;
    Result&lt;proc_macro2::TokenStream, MacroError&gt;
{
    is_c_repr(&amp;input, &quot;#[derive(Object)]&quot;)?;

    let name = &amp;input.ident;
    let parent = &amp;get_fields(&amp;input, &quot;#[derive(Object)]&quot;)?[0].ident;
    ...
}
</pre></div>
</div>
<p>Use procedural macros with care.  They are mostly useful for two purposes:</p>
<ul class="simple">
<li><p>Performing consistency checks; for example <code class="docutils literal notranslate"><span class="pre">#[derive(Object)]</span></code> checks
that the structure has <code class="docutils literal notranslate"><span class="pre">#[repr[C])</span></code> and that the type of the first field
is consistent with the <code class="docutils literal notranslate"><span class="pre">ObjectType</span></code> declaration.</p></li>
<li><p>Extracting information from Rust source code into traits, typically based
on types and attributes.  For example, <code class="docutils literal notranslate"><span class="pre">#[derive(TryInto)]</span></code> builds an
implementation of <code class="docutils literal notranslate"><span class="pre">TryFrom</span></code>, and it uses the <code class="docutils literal notranslate"><span class="pre">#[repr(...)]</span></code> attribute
as the <code class="docutils literal notranslate"><span class="pre">TryFrom</span></code> source and error types.</p></li>
</ul>
<p>Procedural macros can be hard to debug and test; if the code generation
exceeds a few lines of code, it may be worthwhile to delegate work to
“regular” declarative (<code class="docutils literal notranslate"><span class="pre">macro_rules!</span></code>) macros and write unit tests for
those instead.</p>
</section>
<section id="coding-style">
<h3>Coding style<a class="headerlink" href="#coding-style" title="Permalink to this headline"></a></h3>
<p>Code should pass clippy and be formatted with rustfmt.</p>
<p>Right now, only the nightly version of <code class="docutils literal notranslate"><span class="pre">rustfmt</span></code> is supported.  This
might change in the future.  While CI checks for correct formatting via
<code class="docutils literal notranslate"><span class="pre">cargo</span> <span class="pre">fmt</span> <span class="pre">--check</span></code>, maintainers can fix this for you when applying patches.</p>
<p>It is expected that <code class="docutils literal notranslate"><span class="pre">qemu_api</span></code> provides full <code class="docutils literal notranslate"><span class="pre">rustdoc</span></code> documentation for
bindings that are in their final shape or close.</p>
</section>
</section>
<section id="adding-dependencies">
<h2>Adding dependencies<a class="headerlink" href="#adding-dependencies" title="Permalink to this headline"></a></h2>
<p>Generally, the set of dependent crates is kept small.  Think twice before
adding a new external crate, especially if it comes with a large set of
dependencies itself.  Sometimes QEMU only needs a small subset of the
functionality; see for example QEMU’s <code class="docutils literal notranslate"><span class="pre">assertions</span></code> module.</p>
<p>On top of this recommendation, adding external crates to QEMU is a
slightly complicated process, mostly due to the need to teach Meson how
to build them.  While Meson has initial support for parsing <code class="docutils literal notranslate"><span class="pre">Cargo.lock</span></code>
files, it is still highly experimental and is therefore not used.</p>
<p>Therefore, external crates must be added as subprojects for Meson to
learn how to build them, as well as to the relevant <code class="docutils literal notranslate"><span class="pre">Cargo.toml</span></code> files.
The versions specified in <code class="docutils literal notranslate"><span class="pre">rust/Cargo.lock</span></code> must be the same as the
subprojects; note that the <code class="docutils literal notranslate"><span class="pre">rust/</span></code> directory forms a Cargo <a class="reference external" href="https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace">workspace</a>,
and therefore there is a single lock file for the whole build.</p>
<p>Choose a version of the crate that works with QEMU’s minimum supported
Rust version (1.63.0).</p>
<p>Second, a new <code class="docutils literal notranslate"><span class="pre">wrap</span></code> file must be added to teach Meson how to download the
crate.  The wrap file must be named <code class="docutils literal notranslate"><span class="pre">NAME-SEMVER-rs.wrap</span></code>, where <code class="docutils literal notranslate"><span class="pre">NAME</span></code>
is the name of the crate and <code class="docutils literal notranslate"><span class="pre">SEMVER</span></code> is the version up to and including the
first non-zero number.  For example, a crate with version <code class="docutils literal notranslate"><span class="pre">0.2.3</span></code> will use
<code class="docutils literal notranslate"><span class="pre">0.2</span></code> for its <code class="docutils literal notranslate"><span class="pre">SEMVER</span></code>, while a crate with version <code class="docutils literal notranslate"><span class="pre">1.0.84</span></code> will use <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>Third, the Meson rules to build the crate must be added at
<code class="docutils literal notranslate"><span class="pre">subprojects/NAME-SEMVER-rs/meson.build</span></code>.  Generally this includes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">subproject</span></code> and <code class="docutils literal notranslate"><span class="pre">dependency</span></code> lines for all dependent crates</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">static_library</span></code> or <code class="docutils literal notranslate"><span class="pre">rust.proc_macro</span></code> line to perform the actual build</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">declare_dependency</span></code> and a <code class="docutils literal notranslate"><span class="pre">meson.override_dependency</span></code> lines to expose
the result to QEMU and to other subprojects</p></li>
</ul>
<p>Remember to add <code class="docutils literal notranslate"><span class="pre">native:</span> <span class="pre">true</span></code> to <code class="docutils literal notranslate"><span class="pre">dependency</span></code>, <code class="docutils literal notranslate"><span class="pre">static_library</span></code> and
<code class="docutils literal notranslate"><span class="pre">meson.override_dependency</span></code> for dependencies of procedural macros.
If a crate is needed in both procedural macros and QEMU binaries, everything
apart from <code class="docutils literal notranslate"><span class="pre">subproject</span></code> must be duplicated to build both native and
non-native versions of the crate.</p>
<p>It’s important to specify the right compiler options.  These include:</p>
<ul class="simple">
<li><p>the language edition (which can be found in the <code class="docutils literal notranslate"><span class="pre">Cargo.toml</span></code> file)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">--cfg</span></code> (which have to be “reverse engineered” from the <code class="docutils literal notranslate"><span class="pre">build.rs</span></code>
file of the crate).</p></li>
<li><p>usually, a <code class="docutils literal notranslate"><span class="pre">--cap-lints</span> <span class="pre">allow</span></code> argument to hide warnings from rustc
or clippy.</p></li>
</ul>
<p>After every change to the <code class="docutils literal notranslate"><span class="pre">meson.build</span></code> file you have to update the patched
version with <code class="docutils literal notranslate"><span class="pre">meson</span> <span class="pre">subprojects</span> <span class="pre">update</span> <span class="pre">--reset</span> <span class="pre">``NAME-SEMVER-rs</span></code>.  This might
be automated in the future.</p>
<p>Also, after every change to the <code class="docutils literal notranslate"><span class="pre">meson.build</span></code> file it is strongly suggested to
do a dummy change to the <code class="docutils literal notranslate"><span class="pre">.wrap</span></code> file (for example adding a comment like
<code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">version</span> <span class="pre">2</span></code>), which will help Meson notice that the subproject is out of date.</p>
<p>As a last step, add the new subproject to <code class="docutils literal notranslate"><span class="pre">scripts/archive-source.sh</span></code>,
<code class="docutils literal notranslate"><span class="pre">scripts/make-release</span></code> and <code class="docutils literal notranslate"><span class="pre">subprojects/.gitignore</span></code>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="secure-coding-practices.html" class="btn btn-neutral float-left" title="Secure Coding Practices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="index-build.html" class="btn btn-neutral float-right" title="QEMU Build System" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, The QEMU Project Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  

<!-- Empty para to force a blank line after "Built with Sphinx ..." -->
<p></p>

<p>This documentation is for QEMU version 10.0.50.</p>


<p><a href="../about/license.html">QEMU and this manual are released under the
GNU General Public License, version 2.</a></p>

 


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>